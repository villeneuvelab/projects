---
title: "Spatial Extent Paper - Analyses"
output: html_document
date: "2023-09-07"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Author: Frederic St-Onge
Date: September 7th 2023
Updated: November 14th 2023

# Introduction and notes

This document includes all analyses from the paper "Tau accumulation and its spatial progression across the Alzheimerâ€™s disease spectrum" (i.e., Spatial extent or "spex") paper poster on medXriv and currently under review.

The entire markdown document was made to replicate exactly the figures from the manuscript. Provided users downloaded the data indicated in the Python script AND cleaned the data as indicated in the Python script, figures from this script should be identical to the manuscript.

The R code in section 1 executes preliminary preparations needed before running any of the code. Users should, in order:
- Make sure all packages used are downloaded
- Replace the `project_space` and `figure_space` path under the section 1.1 Data Import to where the clean data is located
- Go to section 2 (Table 1) and run all previous chunks of code

From there, the code for each figure is self sustaining: as long as the paths are set correctly, the files expected exist and the packages are installed, users can select which figure or figures to run. Code for each figure also include any code needed to run statistical analyses associated with the figure.

In some cases, functions were created to avoid duplicating the code multiple times. Any functions used across are documented in section 1.4.1.

Code related to reviewer comments are at the end of the script. While the original comment is not included due to privacy issues, the comments are paraphrased.

## Software setup

Below are the packages used in this paper, including a brief note on their use and their version. They are not sorted in any particular order.

```{r}
library(tidyverse) #Data manipulation and graphs with ggplot2 / v.1.3.2
library(performance) #Verify assumptions of linear models / v.0.10.1
library(patchwork) #Plot arrangements working on top of ggplot2 / v.1.1.2
library(glue) #Data manipulation / v.1.6.2
library(lme4) #Longitudinal datas modelisation / v.1.1-30
library(lmerTest) #Computes p-values for lme models / v.3.1-3
library(ggseg) #Brain templates / v.1.6.5
library(tableone) #Facilitates demographic table creation / v.0.13.2
library(nonnest2) #To execute Vuong's test for non-nested models / v.0.5-5
library(dunn.test) #For post-hoc test of Kruskall-Wallis (Supp Figure 4) / v.1.3.5
library(cocor) #For comparing correlation coefficients / v.1.1-4
library(pscl) #For zeroinflated poisson models / v.1.5.5.1

options(scipen=999) #Forces numbers to be output in decimal numbers instead of scientific notation
```

## Analyses

***

### 1. Preliminary preparations

The preliminary preparations section includes mostly importing data, setting up variables for later use and calculating variables we will need for the analyses.

#### 1.1 Data import

```{r}
# Set a "project" path where you will fetch all the data from and output figure to
project_space <- "~/Desktop/vlpp_projects/St_Onge_2023_SpatialExtent/data/derivatives"
figure_space <- "~/Desktop/vlpp_projects/St_Onge_2023_SpatialExtent/docs/figures"

# Main data 
baseline_data <- read_csv(glue("{project_space}/baseline_data.csv")) #Main baseline data

# Longitudinal data
#   Longitudinal data is imported separately because we need to model the slopes individually with LMEs in R
spex_gmm_long_data <- read_csv(glue("{project_space}/spex_metrics_gmm_long.csv")) #Spatial extent metrics (GMM threshold) 
spex_cuneg_long_data <- read_csv(glue("{project_space}/spex_metrics_cu_neg_long.csv")) #Spatial extent metrics (2SD cuneg threshold)
meta_roi_long_data <- read_csv(glue("{project_space}/longitudinal_tau_comp_data.csv")) #SUVR in componant regions

ab_long_data <- read_csv(glue("{project_space}/longitudinal_ab_data.csv")) #Amyloid over time
clindx_long_data <- read_csv(glue("{project_space}/longitudinal_clin_data.csv")) #Clinical diagnosis over time
cog_long_data <- read_csv(glue("{project_space}/longitudinal_cog_data.csv")) #Cognition over time

# Region-wise SPEX and meta-ROI
spex_gmm_regional_mask_data <- read_csv(glue("{project_space}/long_spex_gmm_mask.csv")) #Mask of 0/1 based on GMM thresholds
spex_cuneg_regional_mask_data <- read_csv(glue("{project_space}/long_spex_cu_neg_mask.csv")) #Mask of 0/1 based on CUneg thresholds
suvr_regional_data <- read_csv(glue("{project_space}/suvr_values_long.csv")) #SUVR values across the cortex

# Braak-specific info
spex_gmm_braak_mask_data <- read_csv(glue("{project_space}/long_spex_gmm_braak_mask.csv")) #Mask of 0/1 in Braak based on GMM
spex_cuneg_braak_mask_data <- read_csv(glue("{project_space}/long_spex_cu_neg_braak_mask.csv")) #Mask of 0/1 based on CUneg thresholds
suvr_braak_data <- read_csv(glue("{project_space}/suvr_values_braak_long.csv")) #SUVR values in Braak regions + temporal meta-ROI

# Spatial extent metrics (index)
spex_gmm_braak_long_data <- read_csv(glue("{project_space}/spex_metrics_gmm_braak_long.csv"))
spex_cuneg_braak_long_data <- read_csv(glue("{project_space}/spex_metrics_cu_neg_long.csv"))


```

#### 1.2 Calculations

First, we need to calculate a few things from the longitudinal data. Specifically, we need to calculate the slopes of variables we want to use in our longitudinal analyses. This needs to be done first as we need to display them in the demographics table and we will need them in most analyses.

First, we create functions to reuse for all longitudinal measures.

```{r}
max_nb_visit <- function(data, id, var, name) {
    "Function computing the total number of visits per participant.
    
    data = dataframe object with longitudinal visits per participant
    id = Name of the identifying column for the data. Should not be a string.
    var = Name of the variable containing the number of visits
    name = Name of the variable. This will name the resulting column of the new dataframe, prefixed by 'max_'
    
    Returns a dataframe with a single number by participant representing the number of visits available.
    "
    max_visits <- data %>%
        group_by({{id}}) %>% #Group by the ID variable
        summarise('max_{name}' := max({{var}})) #Compute the maximum value by ID (i.e., max visits)
    
    return(max_visits)
}

time_since_bl <- function(data, id, distinct_col, time_col, name) {
    "Function computing the time (in years) since the baseline (i.e., first visit available) for a participant.
    
    data = dataframe object with longitudinal visits per participant.
    id = Name of the ID column for the participant (Not a string)
    distinct_col = Column to check for the number of visits (will exclude participants with less than 2 visits)
    time_col = Column with dates to use to calculate the time since baseline
    name = name to tag to the variables created
    "
    time_df <- data %>%
        group_by({{id}}) %>%
        mutate("{name}_years" := replace_na( #Make sure lag is from dplyr and not something else.
                   (as.numeric(as.Date({{time_col}}) - dplyr::lag(as.Date({{time_col}}))) / 365.25), 0))%>%
        #Substract each subsequent date and store in variable.
        #When the substraction gives missing, it means it's the first visit. In taht case, replace by 0
        mutate("cum_{name}_years" := cumsum(.data[[glue("{name}_years")]])) %>% 
        #For each group, compute the cumulative sum of the time since BL. This is a bit complex coding
        #as we need to call the .data pronoun to refer to the current dataframe (lambda x in python)
        # and then glue the string.
        filter(n_distinct({{distinct_col}}) >=2 ) #Filter out participants with no longitudinal visits
    
    return(time_df)
}

slope_over_time <- function(data, id, outcome_var, time_var, name) {
    "Function computing the slope of a variable based on time as a random slope and intercept.
    
    data = time_df dataframe computed with the function 'time_since_bl'
    id = Name of the ID column for the participant (must be given as a string)
    outcome_var = Name of the column for which we want a slope (must be given as a string)
    time_var = Name of the column with the information on the time since baseline (must be given as a string)
    name = Name to tag the new variables with
    "
    
    lmer_model <- lmer(glue("{outcome_var} ~ {time_var} + ({time_var}|{id})"), data=data) #Change over time, with random slopes and intercepts
    annual_change <- coef(lmer_model)[[1]] %>% #Extract the coefficients, which are arranged by IDs (first column)
        rename('baseline_{name}' := `(Intercept)`) %>% #Extract the intercept, which in an LME, is the baseline
        rename('annual_slope_{name}' := time_var) %>% #Extract the annual change in the variable
        rownames_to_column(var=id) %>% #IDs are stored as rownames, but we want it as a column
        mutate("{id}" := as.numeric(.data[[glue("{id}")]])) #Convert the ID, which is a string, to a number, to match the index from other data.
    
    return(annual_change)
}


```

Next, we compute the slopes at the individual level for each variable using linear mixed models. For each variable, we need to run the three functions above.

```{r}
# Meta_roi
nb_tau_pet <- max_nb_visit(meta_roi_long_data, id=RID, var=tau_pet_number, name='tau_pet_number')
meta_roi_time_calc <- time_since_bl(data=meta_roi_long_data, id=RID, distinct_col = tau_pet_number, time_col = EXAMDATE_tau, name='meta_roi')
meta_roi_annual_change <- slope_over_time(data=meta_roi_time_calc, id="RID", outcome_var = "meta_roi_tau_jack_tau", time_var = "cum_meta_roi_years", name='meta_roi')

# Spex - We don't calculate max tau PET again as it was calculated for meta-ROI
spex_gmm_time_calc <- time_since_bl(data=spex_gmm_long_data, id=RID, distinct_col = tau_pet_number, time_col = EXAMDATE_tau, name='spex_gmm')
spex_gmm_annual_change <- slope_over_time(data=spex_gmm_time_calc, id='RID', outcome_var='spatial_extent_thresh_0.5', time_var = 'cum_spex_gmm_years', name='spex_gmm')

spex_cuneg_time_calc <- time_since_bl(data=spex_cuneg_long_data, id=RID, distinct_col = tau_pet_number, time_col = EXAMDATE_tau, name='spex_cuneg')
spex_cuneg_annual_change <- slope_over_time(data=spex_cuneg_time_calc, id='RID', outcome_var='spatial_extent_thresh_2sd_cu_ab_neg', time_var = 'cum_spex_cuneg_years', name='spex_cuneg')

# Amyloid
nb_ab_pet <- max_nb_visit(ab_long_data, id=RID, var=ab_pet_number, name='ab_pet_number')
ab_time_calc <- time_since_bl(data=ab_long_data, id=RID, distinct_col = ab_pet_number, time_col=EXAMDATE_AB, name='centiloid')
ab_annual_change <- slope_over_time(data=ab_time_calc, id='RID', outcome_var='centiloid', time_var = 'cum_centiloid_years', name='centiloid')

# Cog - Memory
nb_cog <- max_nb_visit(cog_long_data, id=RID, var=cog_number, name='cog')
cog_time_calc <- time_since_bl(data=cog_long_data, id=RID, distinct_col = cog_number, time_col=EXAMDATE_COG, name='cog')
cogmem_annual_change <- slope_over_time(data=cog_time_calc, id='RID', outcome_var='ADNI_MEM', time_var='cum_cog_years', name='adnimem')

#Cog - Executive
cogef_annual_change <- slope_over_time(data=cog_time_calc, id='RID', outcome_var='ADNI_EF', time_var='cum_cog_years', name='adnief')

#Cog - Language
coglan_annual_change <- slope_over_time(data=cog_time_calc, id='RID', outcome_var='ADNI_LAN', time_var='cum_cog_years', name='adnilan')

#Cog - Visuospatial
cogvis_annual_change <- slope_over_time(data=cog_time_calc, id='RID', outcome_var='ADNI_VSP', time_var='cum_cog_years', name='adnivsp')
```

#### 1.3 Creating final dataframes

Once the slopes are calculated, we can join everything together with the baseline data

```{r}
final_data <- baseline_data %>%
    #Next is longitudinal information for each participant
    left_join(nb_tau_pet) %>%
    left_join(nb_ab_pet) %>%
    left_join(nb_cog) %>%
    left_join(meta_roi_annual_change) %>%
    left_join(spex_gmm_annual_change) %>%
    left_join(spex_cuneg_annual_change) %>%
    left_join(ab_annual_change) %>%
    left_join(cogmem_annual_change) %>%
    left_join(cogef_annual_change) %>%
    left_join(coglan_annual_change) %>%
    left_join(cogvis_annual_change)
```


#### 1.4 Additional ressources

##### 1.4.1 - Functions to reuse

```{r}
#Function to print the p-values of the different comparisons
demog_comp_check <- function(data, ab_stat) {
    "Function checking all variables given by user for group difference and outputs the significance (p-value).
    Depending on the need of the user, the difference in mean can be output for the Tukey.
    
    data = Data to pull the demographic information from
    ab_stat = Whether we want to look at amyloid-negative or amyloid-positive participants
    "
    #For now, we apply the function to these variables
    for (vars in c('PTGENDER', 'apoe_bin', "PTAGE", "PTEDUCAT", "centiloid", "ADNI_MEM", "ADNI_EF", "ADNI_LAN", "ADNI_VSP", "max_tau_pet_number", "max_cog")) {
        if (is.numeric(data[[glue('{vars}')]])){ #Force select the right amyloid positivity
            #In the case where the data is continuous, we do a Tukey test
            tukey_store <- TukeyHSD(aov(data[[glue('{vars}')]] ~ data[['DIAGNOSIS']]))[[1]]
            #We print the p-values
            print(glue("{ab_stat} - {vars}: MCI-CU {round(tukey_store[10], 3)} / AD-CU {round(tukey_store[11], 3)} / AD-MCI {round(tukey_store[12], 3)}"))
        } else {
            pval_store <- chisq.test(data[[glue('{vars}')]], data[['DIAGNOSIS']])
            print(glue("{ab_stat} - {vars}: Overall Diff {round(pval_store$p.value, 3)}"))
        }
    }
    
}

#Function to prepare data for Figure 3B and 3C
roi_summarize_bl <- function(data, DIAG, SIZE=NA){
    "Function to manipulate the data for each group before plotting brain templates. It can plot either a mean of a value 
    across participants or a percentage of an outcome in participants.
    
    data = Variable mask_map_regional_se_gmm_bl
    DIAG = Diagnosis of interest (CU, MCI or AD)
    SIZE = If size is given, we want a percentage as output. Otherwise, we want the average.
    "
    roi_clean <- data %>%
        filter(DIAGNOSIS == DIAG) %>% #Select the right diagnostic category
        select(-DIAGNOSIS) %>% #Remove the diagnosis column since we don't need it anymore
        summarize(across(everything(),
                         #For every column, we want to summarize, but do it differently depending on the SIZE variable
                         #If SIZE is given, we will want a percentage in the end. Otherwise, we just want the average.
                         ~case_when(
                             is.numeric(SIZE) ~ sum(.x, na.rm = TRUE), #When size is null, we average
                             TRUE ~ mean(.x, na.rm = TRUE))) #When size is a number, we do a percentage in the last line, so we need the sum now.
                  ) %>%
        pivot_longer(cols = everything(), names_to = "label", values_to = "brain_val") %>% #Pivot wide to long, so each row is a brain region
        mutate(label = tolower(label)) %>% #Decapitalize the letters
        mutate(label = str_remove(label, "^ctx_")) %>% #Remove the prefix and suffix so it fits with ggseg nomenclature
        mutate(label = str_remove(label, "_suvr")) %>% 
        #Modify the brain_val value: when size is given, we do a percentage. Otherwise, just output the same variable
        mutate(brain_val = case_when(is.numeric(SIZE) ~ (brain_val / SIZE) * 100,
                                     TRUE ~ brain_val))
    
    return(roi_clean)
}

#Function for Figure 3B and C, and 6
brain_template_plotting <- function(data_brain, limits_y, legend_name, plot_name) {
    "A simple function to plot values on brain templates.
    
    data_brain = Data containing ready-to-plot values for ggseg (1 column with `label`, 1 column with `brain_val`). brain_val can be any numeric variable to plot on the brain
    limits_y = Limits for scale
    legend_name = Name of the legend
    plot_name = Title of the plot (in this case, it should probably be 'DIAGNOSIS AB+')
    "
    
    ggseg_plot <- ggplot(data_brain) +
        geom_brain(atlas=dk, #Desikan atlas
                   color='white', #Color of the borders between regions
                   position=position_brain(hemi ~ side), #Position of the brain (2 rows, side and middle, side and middle)
                   aes(fill = brain_val)) + #Fill the regions by the value of interest
        #Add two points for the amygdalas. The position was determined from the plot before adding theme_void()
        #Amygdalas are not added by default because it is not cortical, so the position is approximate
        geom_point(data = subset(data_brain, label %in% c("lh_amygdala")), aes(548, y=29, fill=brain_val), shape=21, color="white", size=3.5) +
        geom_point(data = subset(data_brain, label %in% c("rh_amygdala")), aes(490, y=275, fill=brain_val), shape=21, color="white", size=3.5) +
        theme_void() + #Remove all axis
        scale_fill_viridis_c(option="plasma", na.value="grey", limits=limits_y, name=legend_name) + #Colors the plot in a gradient
        ggtitle(plot_name) + 
        theme(plot.title = element_text(hjust = 0.5, face='bold', size=18), #Arrange the plot title to look nice
              legend.position = "bottom")
    
    return(ggseg_plot)
}

#Compute the slopes for Figure 4
region_wise_slopes <- function(data_long, DIAG, SIZE=NA){
    "Function to compute region-wise slopes for Figure 4B and C
    
    data_long = Data containing the longitudinal data to use for the slopes
    DIAG = Diagnosis of interest to derive the slopes from
    TYPE = Whether we are calculating the slopes for spatial extent or for SUVR
    "
    
    roi_clean_long <- data_long %>%
        filter(DIAGNOSIS == DIAG) %>%
        group_by(tau_pet_number, DIAGNOSIS) %>% #Group the data by the tau_pet_number and the diagnosis
                                                # as we want to find the average time for people in each diagnostic group
        #We summarise all columns, except the time column. If the SIZE argument is numeric, it means we will calculate the spatial extent.
        #When that is the case, we want the % number of regions as the final outcome to plot, so we sum values here. Otherwise, we just
        # average the SUVRs for each region.
        summarise(across(-cum_meta_roi_years, ~case_when(is.numeric(SIZE) ~ sum(.x), 
                                                         TRUE ~ mean(.x))),
                  average_time = mean(cum_meta_roi_years, na.rm=TRUE)) %>% #We also compute the average time for each diagnosis, for each timepoint
        #Flip to longer form to get 1 value per 1 region, for each diagnosis, for each timepoint
        pivot_longer(cols = -c(DIAGNOSIS, tau_pet_number, average_time), names_to = 'label', values_to = 'brain_val_long') %>%
        #The next few lines change the name of the regions to match ggseg appelation
        mutate(label = tolower(label)) %>%
        mutate(label = str_remove(label, "^ctx_")) %>%
        mutate(label = str_remove(label, "_suvr")) %>%
        ungroup()
    
    #Next, for each brain region, we use LME to find the slope of tau in that brain region
    slope_by_region <- coef(lmer(brain_val_long ~ average_time + (average_time|label), data=roi_clean_long))$label[2] %>%
        rename(regional_long_change_tau = average_time) %>% #Rename for clarity 
        #When we use the spatial extent, we want a % change of the sample rather than just the number of regions
        mutate(regional_long_change_tau = case_when(is.numeric(SIZE) ~ (regional_long_change_tau / SIZE) * 100,
                                            TRUE ~ regional_long_change_tau)) %>%
        #Rename the first column to "label" so ggseg recognizes it.
        rownames_to_column(var='label')
    
    return(slope_by_region)
    
}

#Function for figure 4B and C
brain_template_plotting_long <- function(data_brain, limits_y, legend_name, plot_name) {
    "A simple function to plot longitudinal values on brain templates.
    
    data_brain = Data containing ready-to-plot values for ggseg (1 column with regions, 1 column with values)
    limits_y = Limits for scale
    legend_name = Name of the legend
    plot_name = Title of the plot (in this case, it should probably be 'DIAGNOSIS AB+')
    "
    
    ggseg_plot <- ggplot(data_brain) +
        geom_brain(atlas=dk, #Desikan atlas
                   color='white', #Color of the borders between regions
                   position=position_brain(hemi ~ side), #Position of the brain (2 rows, side and middle, side and middle)
                   aes(fill = regional_long_change_tau)) + #Fill the regions by the value of interest
        #Add two points for the amygdalas. The position was determined from the plot before adding theme_void()
        #Amygdalas are not added by default because it is not cortical, so the position is approximate
        geom_point(data = subset(data_brain, label %in% c("lh_amygdala")), aes(x=548, y=29, fill=regional_long_change_tau), shape=21, color="white", size=3.5) +
        geom_point(data = subset(data_brain, label %in% c("rh_amygdala")), aes(x=490, y=275, fill=regional_long_change_tau), shape=21, color="white", size=3.5) +
        theme_void() + #Remove all axis
        scale_fill_viridis_c(option="plasma", na.value="grey", limits=limits_y, name=legend_name) + #Colors the plot
        ggtitle(plot_name) +
        theme(plot.title = element_text(hjust = 0.5, face='bold', size=18),
              legend.position = "bottom")
    
    return(ggseg_plot)
}

#Association between tau measures and outcomes
# These functions all work together to generate the plots seen, for example, in Figure 5
### This is the main function. It actually plots each individual plot
plot_bio_function <- function(df, bio, outcome, lim_x_vals, lim_y_vals, col_points, 
                              beta_coef, beta_coef_sca, pstar, r2adj, aic_val, 
                              x_lab_val, y_lab_val) {
    
    "bio = Name of the variable to use as predictor (i.e., biological variable, either meta-ROI or spatial extent)
    outcome = Name of the variable to use as the outcome (e.g., cognition, demographic, etc.)
    lim_x_vals = Values to give to the x-axis as limits (set automatically by the `lim_x_val_funct` since the distribution is always the same on the x-axis)
    lim_y_vals = Values to give to the y-axis as limits
    col_points = Colors of the points on the graph (this is automatially determined by the function `col_points_funct`)
    beta_coef = Raw beta coefficient from the models (this is automatically determined by the function `biom_comp`)
    beta_coef_sca = Scaled beta coefficient (automatically determined by the function `biom_comp`)
    pstar = Statistical significance to plot (either *, ** or ***, which represents 0.05, 0.01, or 0.001; automatically calculated from 
    `pstar` function
    r2adj = Variance explained by the full model (automatically determined by the function `biom_comp`)
    aic_val = Akaike Information Criterion (automatically determined)
    x_lab_val = Name to give to the x-axis
    y_lab_val = Name to give to the y-axis
    "
    #Let's plot the data
    plot_bio <- df %>%
      ggplot(aes_string(x=glue("{bio}"), y=glue("{outcome}")), color=glue("{col_points}")) + #Col_points gives the color of the provided string to all layers
      geom_point(color=glue("{col_points}"), shape=21, fill=glue("{col_points}"), alpha=0.6) + #We orce the colors here due to issues
      stat_smooth(fill=glue("{col_points}"), color=glue("{col_points}"), formula = y~x, method = "lm", fullrange = TRUE) + #Full range plots the lm all the way to the edge of the graph, rather than just on the data. It looks nicer
      theme_classic() + 
      ylim(lim_y_vals) +
      xlim(lim_x_vals) +
      annotate("text", y=Inf, x =Inf, hjust=1, vjust=1,  #We add the stats information on the graph
           label=glue("\U03B2 = {beta_coef} {pstar}\n\U03B2std = {beta_coef_sca}\nR\U00B2 adj = {r2adj}\nAIC = {aic_val}")) +
      xlab(glue("{x_lab_val}")) +
      ylab(glue("{y_lab_val}")) +
      theme(panel.grid.major = element_line(), #Reimports the axis grid (1/2)
          panel.grid.minor = element_line(), #Reimports the axis gris (1/2)
          #text = element_text(size=10, family="sans"), #Imposes font family and size
          text = element_text(family="sans"), #Imposes font family and size
          axis.title.x = element_text(face="bold"), #Bolds the axis title
          axis.title.y = element_text(face="bold"),
          aspect.ratio = 1) #Ensures a square is outputted
    
    return(plot_bio)
}


pstar_funct <- function(pval) {
    "Simple function taking the p-value of the models for the predictor of interest. It outputs
    either *** if the p-value is less than 0.001, ** if less than 0.01, * if less than 0.05 or 
    \U00B0 (degree symbol) if less than 0.1. 
    
    pval = p-value of the models
    "
  
    if (pval < 0.001) {
          pstar = "***"
    } else if (pval < 0.01) {
          pstar = "**"
    } else if (pval < 0.05) {
          pstar = "*"
    } else if (pval < 0.1) {
          pstar = "\U00B0"
    } else {
      pstar = ""
    }
  
  return(pstar)
}

col_points_funct <- function(pop) {
    "Simple function selecting the color depending on the diagnostic group chosen.
    
    pop = String representing the population of interest, either CU, MCI or AD
    "
  
    if (pop == 'WS') { #Full sample
      col_points = "black"
    } else if (pop == 'CU') { 
      col_points = "#44C8F5"
    } else if (pop == 'MCI') { 
      col_points = "#F7941D"
    } else if (pop == 'AD') { 
      col_points = "#ED1B2F"
    }
  
  return(col_points)
}

biom_comp <- function(df, bio, outcome, x_lab_val, lim_x_vals, y_lab_val, lim_y_vals, lm_diagnostics) {
    "Function creating plots for a given population between an outcome and a predictor.
    The function outputs a patchwork where the plots for the same group are outputted on top of
    one another.
    
    df = Data to use for the plot (must contain the predictor `bio` and the outcome `outcome`)
    bio = String representing the name of the column of the predictor
    outcome = String representing the name of the column of the outcome
    x_lab_val = String representing the label to give to the x-axis
    lim_x_vals = Values the x-axis should be limited to (give as a list of numeric like c(1,2))
    y_lab_val = String representing the label to give to the y-axis
    lim_y_vals = Values the y-axis should be limited to (give as a list of numeric like c(1,2))
    lm_diagnostics = Whether we want to plot the linear model diagnostics for the model. This will output the same
    thing as if running `plot(lm)` (i.e., linearity, normality, heteroscedasticity, outliers)
    

"
    
  #Create list to store the graphs
    list_graph <- list()

  #Create the dataframes to use for the analyses
   for (pop in c('WS', 'CU', 'MCI', 'AD')) {
       #First, reduce the sample to only the diagnosis of interest
       if (pop == 'WS') {
           df_red <- df
       } else {
          df_red <- df %>%
           filter(DIAGNOSIS == pop)
       }
        
        #Covariate model, not scaled
        lm_cov_bio <- NULL
        #If we use age as the outcome, we don't want to also control for age. Otherwise, we do want to control for age
        if (outcome == "PTAGE") {
            lm_cov_bio <- lm(glue("{outcome} ~ {bio} + PTGENDER + PTEDUCAT"), data=df_red)
                if (lm_diagnostics == 'yes') {
            plot(lm_cov_bio) #Plot regression diagnosis
            print(vif(lm_cov_bio)) #Check multicolinearity
        }} else {
            lm_cov_bio <- lm(glue("{outcome} ~ {bio} + PTAGE + PTGENDER + PTEDUCAT"), data=df_red)
                if (lm_diagnostics == 'yes') {
            plot(lm_cov_bio) #Plot regression diagnosis
            print(vif(lm_cov_bio))} #Check multicolinearity
        }
        
        #Covariate model, scaled
        lm_sca_bio <- NULL
        if (outcome == "PTAGE") { #Same comment as above for age
            lm_sca_bio <- lm(glue("scale({outcome}) ~ scale({bio}) + PTGENDER + scale(PTEDUCAT)"),
                             data=df_red)
         } else {
            lm_sca_bio <- lm(glue("scale({outcome}) ~ scale({bio}) + scale(PTAGE) + PTGENDER + scale(PTEDUCAT)"),
                             data=df_red)
         }
        
        #Compute the model estimates for the models with covariates
        sum_cov_bio <- summary(lm_cov_bio)
        sum_cov_bio_scaled <- summary(lm_sca_bio)
    
        beta_coef_cov <- format(signif(sum_cov_bio$coefficients[2,1], digits=2), 
                                nsmall=2) #Get the beta coefficient
        beta_coef_cov_scaled <- format(signif(sum_cov_bio_scaled$coefficients[2,1], 
                                              digits=2), nsmall=2) #Get the standardized beta
        pval <- sum_cov_bio$coefficients[2,4] #We take the p-value of the corrected model
        r2adj <- format(round(sum_cov_bio$adj.r.squared, 2), nsmall=2)
        aic_val <- format(round(AIC(lm_cov_bio), 2), nsmall=2)
        
        #Quick function to replace pvalue by stars
        pstar <- pstar_funct(pval)
        
        #Moving to the graph. Set a color depending on the cohort of interest
        col_points <- col_points_funct(pop)
        
        #Create the graph with the pre-made specifications
        list_graph[[pop]] <- plot_bio_function(df=df_red, bio=bio, outcome=outcome, lim_x_vals=lim_x_vals, 
                                           lim_y_vals=lim_y_vals, col_points=col_points, 
                                           beta_coef=beta_coef_cov, beta_coef_sca=beta_coef_cov_scaled,
                                           pstar=pstar, r2adj=r2adj, aic_val=aic_val, 
                                           x_lab_val=x_lab_val, y_lab_val=y_lab_val)
        
        
   } #BRACKET OF POP LOOP
  
    #Use patchwork to wrap up all plots in together
    patched_tau_plots <- patchwork::wrap_plots(list_graph, nrow=1)

  #Return plots (1 row per group)
  return(patched_tau_plots)
}

# Function for Figure 6 (generates empty dataframes to store the data for the region-wise)
blank_df_region_wise <- function(data) {
    "Function specific to Figure 6. It creates an empty dataframe with the labels of the regions and empty columns to store the data.
    
    data = Data, specifically, the mask_map_regional_[SUVR/SPEX]_bl variables
    "
    roi_labels_region_wise <- mask_map_regional_suvr_bl %>%
        select(-DIAGNOSIS) %>%
        summarise(across(CTX_LH_BANKSSTS_SUVR:CTX_RH_AMYGDALA_SUVR, ~mean(.x))) %>% #Here, we use summarize just so we don't get 20,000 rows. It will give 1 row per region
        pivot_longer(cols = everything(), names_to = "label", values_to = "spatial_extent_index") %>% #Flip to long format
        mutate(label = tolower(label)) %>%
        mutate(label = str_remove(label, "^ctx_")) %>%
        mutate(label = str_remove(label, "_suvr")) %>%
        add_column(beta = NA) %>% #This will store the beta coefficients
        add_column(std_beta = NA) %>% #This will store the standardized betas
        add_column(p_unc = NA) %>% #This will store the uncorrected p_val
        add_column(p_cor = NA) %>% #This will store the corrected p_val (with FDR)
        select(-spatial_extent_index) #Remove the column that was created from the summarize and pivot
    
}

#Function for Figure 6 (generates the region-wise figures)
region_wise_regressions <- function(data, cog_vars, DIAG, fill_lims) {
    "Complicated function computing region-wise analyses. It is quite too complex, but it works.
    "
    list_plots <- list() #List to store the plots
    
    #First, iterate over all cognitive measures of interest
    for (COG_VAR in cog_vars) {
        
        #Clean the data for use
        data_red <- data %>%
            filter(DIAGNOSIS == DIAG) %>% #Keep only diagnosis of interest
            select(-DIAGNOSIS) %>% #Remove the diagnosis column (no longer need it)
            select(any_of(COG_VAR), PTAGE, PTGENDER, PTEDUCAT, contains("CTX_")) %>% #Keep only covariables and cortical regions
            select(any_of(COG_VAR), PTAGE, PTGENDER, PTEDUCAT, sort(colnames(.))) #Sort the columns of cortical regions
        
        roi_labels_region_wise_cp <- blank_df_region_wise(mask_map_regional_suvr_bl) #Create a blank dataframe to store the regression results
         
        #Function looping over all of the brain regions and doing linear regression for each region
        for (roi in 5:ncol(data_red)){
                    #We do a LM model where the cognitive variable is the outcome, the SUVR the predictor and age, sex and education the covariates
                    roi_lm <- lm(data_red[[glue('{COG_VAR}')]] ~ data_red[[roi]] + data_red[['PTAGE']] + 
                            as.factor(data_red[['PTGENDER']]) + data_red[['PTEDUCAT']])
                    #We also output standardized information if we need
                    roi_lm_std <- lm(scale(data_red[[glue('{COG_VAR}')]]) ~ scale(data_red[[roi]]) + scale(data_red[['PTAGE']]) + 
                            as.factor(data_red[['PTGENDER']]) + scale(data_red[['PTEDUCAT']]))
                
                #Extract the beta and p-values from the models, and store them
                roi_labels_region_wise_cp[roi - 4, "beta"] <- summary(roi_lm)$coefficients[2,1]
                roi_labels_region_wise_cp[roi - 4, "p_unc"] <- summary(roi_lm)$coefficients[2,4]
                roi_labels_region_wise_cp[roi - 4, "std_beta"] <- summary(roi_lm_std)$coefficients[2,1]
         } #End of the region-wise regression loop
        
        #Adjust the p-values for multiple comparisons
        roi_labels_region_wise_cp$p_cor <- p.adjust(roi_labels_region_wise_cp$p_unc, method="fdr")
        
        #Transform the p-values to positive/negative and uncorrected/corrected for easier filtering later
        roi_labels_region_wise_cp <- roi_labels_region_wise_cp %>%
            mutate(pos = ifelse(p_cor < 0.05, "cor", ifelse(p_unc < 0.05, "unc", "no"))) %>%
            mutate(pos_bin = ifelse((pos == "no" | pos == "unc"), "no_asso", "asso")) %>%
            mutate(beta_bin_cor = ifelse(pos_bin == "asso", std_beta, 0)) %>% #In the case where there is an association, assign the standardize beta, otherwise 0
            mutate(beta_bin_unc = ifelse((pos == "unc" | pos_bin == "asso"), std_beta, 0))
        
        print(roi_labels_region_wise_cp) #Not necessary, but allows to check for min/max values to scale the plots
        
        #Next, we store the plots for each cognitive measure into a list
        list_plots[[COG_VAR]] <- ggplot(roi_labels_region_wise_cp) +
            #If there is at least one region with SUVR values, then we plot the betas
            {if(sum(roi_labels_region_wise_cp$beta_bin_cor, na.rm = TRUE) != 0)geom_brain(atlas=dk,
                 colour="white",
                 position=position_brain(hemi ~ side),
                 aes(fill = beta_bin_cor))} +
            #If all regions are missing, we plot a "grey" brain
            {if(sum(roi_labels_region_wise_cp$beta_bin_cor, na.rm = TRUE) == 0)geom_brain(atlas=dk,
                 colour="white",
                 position=position_brain(hemi ~ side),
                 fill = "grey")} +
            #Same logic as above, but whether or not the amygdalas should be the color of the betas, or if no betas, it should be grey
            {if(sum(roi_labels_region_wise_cp$beta_bin_cor, na.rm = TRUE) != 0)geom_point(aes(x=548, y=29, 
                                                                                        fill=beta_bin_cor),
                                                                                        shape=21, color="white", size=3.5)} +
            {if(sum(roi_labels_region_wise_cp$beta_bin_cor, na.rm = TRUE) == 0)geom_point(aes(x=548, y=29), 
                                                                                        fill="grey",
                                                                                        shape=21, color="white", size=3.5)} +
            {if(sum(roi_labels_region_wise_cp$beta_bin_cor, na.rm = TRUE) != 0)geom_point(aes(x=490, y=275, 
                                                                                        fill=beta_bin_cor),
                                                                                        shape=21, color="white", size=3.5)} +
            {if(sum(roi_labels_region_wise_cp$beta_bin_cor, na.rm = TRUE) != 0)geom_point(aes(x=490, y=275,),
                                                                                        fill="grey",
                                                                                        shape=21, color="white", size=3.5)} +
            scale_fill_viridis_c(option="plasma", na.value="grey", limits=fill_lims, name="\U03B2std coefficient", direction = -1) +
            theme_void() +
            #Assign a title to the plot depending on the variable the function is currently using.
            ggtitle(case_when((COG_VAR == "ADNI_MEM" | COG_VAR == "annual_slope_adnimem") ~ "Memory",
                          (COG_VAR == "ADNI_EF" | COG_VAR == "annual_slope_adnief") ~ "Executive",
                          (COG_VAR == "ADNI_LAN" | COG_VAR == "annual_slope_adnilan") ~ "Language",
                          (COG_VAR == "ADNI_VSP" | COG_VAR == "annual_slope_adnivsp") ~ "Visuospatial")) +
            #Sets the title for each brain template. 
            theme(legend.position = "bottom", legend.text = element_text(angle=45, vjust = 0.5, size=14), legend.title = element_text(size = 16), legend.key.width = unit(1.5, "cm"), plot.title = element_text(face = "bold", hjust=0.5, size=28))
    }
    
    patch_plot <- patchwork::wrap_plots(list_plots, nrow=1, guides = "collect") & theme(legend.position = "bottom") #Wrap all 4 domains, and set legend to bottom

    return(patch_plot)
}

#Supp figure 3 and lmer data
lmer_tau <- function(data, diag, outcome, time, covar=NULL){
    "Simple function creating and outputing LMEs based on conditions defined by the user.
    
    Data = Data to be used for the models
    Diag = Diagnosis of the group of interest (CU, MCI or AD)
    outcome = Outcome to measure change over time
    Time = Time variable to use in the models
    covar = Covariates to use, if any
    
    returns: tibble containing the intercept, beta, error and p-values of the main predictors in the model.
    "
    
    simp_formula <- glue("{outcome} ~ {time} + ({time}|RID)")
    covar_formula <- glue("{outcome} ~ {time} + {covar} + ({time}|RID)")
    print(covar_formula)
    
    data_diag <- data %>% filter(DIAGNOSIS == diag)
        
    #Execute the models
    lmer_simp <- summary(lmer(simp_formula, data=data_diag))
    lmer_covar <- ifelse(is.null(covar), NULL, list(summary(lmer(covar_formula, data=data_diag))))
    #print(lmer_covar)
    
    #Create a tibble to store the data from the models
    coeffs <- tribble(
        ~model, ~intercept, ~beta, ~error, ~pval,
        "Simple LMER", lmer_simp$coefficients[1,1], lmer_simp$coefficients[2,1], lmer_simp$coefficients[2,2], lmer_simp$coefficients[2,5],
        "Covariate LMER", ifelse(is.null(lmer_covar), NULL, lmer_covar[[1]]$coefficients[1,1]), ifelse(is.null(lmer_covar), NA, lmer_covar[[1]]$coefficients[2,1]), ifelse(is.null(lmer_covar), NULL, lmer_covar[[1]]$coefficients[2,2]), ifelse(is.null(lmer_covar), NA, lmer_covar[[1]]$coefficients[2,5])
    )

    return(coeffs)
    
}

#Functions for the Jaccard Similarity Index

jaccard_bin <- function(a, b) {
    "Function computing the Jaccard coefficient between two binary arrays
    
    a = first binary array
    b = second binary array
    "
  
  intersecting <- 0 #Count the number of intersection here
  for (e in 1:length(a)) { #For every value in the first array...
    
    if (a[e] == b[e]) { #If the value in the first array equals the value in the same position of the second array...
      intersecting <- intersecting + 1 #It intersects, so add 1
    } else {
      intersecting <- intersecting + 0
    }
  }
  
  union_data <- length(a) + length(b) - intersecting #Union is the size of the two arrays, minus their intersection
  #In a Venn Diagram, it would be the part that is not in the middle.
  
  return(intersecting/union_data) #Jaccard index is intersection (how many intersect) divided by the union
}

jacc_alike_coef <- function(data, ids) {
    "Compute the Jaccard coefficient between each pair of participant and calculate the average for each participant.
    
    data = Data to compute the Jaccard Coefficient on (regional data)
    ids = Data containing the IDs of the participants in the right order.
    
    "
  
  mat_jacc <- matrix(ncol = nrow(data), nrow = nrow(data)) #Create empty matrix to store the results
  
  #Loop of all participants
  for (i in 1:nrow(data)) {
    vec_1 <- as.numeric(data[i,]) #Select a single row
    for (j in 1:nrow(data)) {
      vec_2 <- as.numeric(data[j,])
      
      mat_jacc[i,j] <- jaccard_bin(vec_1, vec_2) #Compute the Jaccard index
    }
  }
  
  diag(mat_jacc) = NA #In this case, Jaccard when i == j (same individual) would yield an index of 1. So we exclude it.
  avg_sim <- rowMeans(mat_jacc, na.rm=TRUE) #Compute the average of each row (on average, how similar is a participant to the next). We exclude NA to avoid the diagonal of the matrix.
  
  #diag(mat_corr) = NA
  #avg_cor <- rowMeans(mat_corr, na.rm=TRUE)
  
  #Add back the column to the IDs and output
  data_red <- ids %>%
    select(RID) %>%
    bind_cols(avg_sim) %>%
    rename("avg_jack_coef" = "...2")
  
  return(data_red)
}

```


##### 1.4.2 - Variables to reuse

In this section we store additional code we need to run some of the analyses.

```{r}
#Create lists holding the name of regions included in each Braak stage
braak_1_regs = c("CTX_LH_ENTORHINAL_SUVR", "CTX_RH_ENTORHINAL_SUVR")
braak_3_regs = c("CTX_LH_AMYGDALA_SUVR", "CTX_RH_AMYGDALA_SUVR",
                                 "CTX_LH_FUSIFORM_SUVR", "CTX_RH_FUSIFORM_SUVR",
                                 "CTX_LH_PARAHIPPOCAMPAL_SUVR", "CTX_RH_PARAHIPPOCAMPAL_SUVR",
                                 "CTX_LH_LINGUAL_SUVR", "CTX_RH_LINGUAL_SUVR")
braak_4_regs = c("CTX_LH_TEMPORALPOLE_SUVR", "CTX_RH_TEMPORALPOLE_SUVR",
                                 "CTX_LH_INFERIORTEMPORAL_SUVR", "CTX_RH_INFERIORTEMPORAL_SUVR",
                                 "CTX_LH_MIDDLETEMPORAL_SUVR", "CTX_RH_MIDDLETEMPORAL_SUVR",
                                 "CTX_LH_ISTHMUSCINGULATE_SUVR", "CTX_RH_ISTHMUSCINGULATE_SUVR",
                                 "CTX_LH_CAUDALANTERIORCINGULATE_SUVR", "CTX_RH_CAUDALANTERIORCINGULATE_SUVR",
                                 "CTX_LH_INSULA_SUVR", "CTX_RH_INSULA_SUVR",
                                 "CTX_LH_POSTERIORCINGULATE_SUVR", "CTX_RH_POSTERIORCINGULATE_SUVR",
                                 "CTX_LH_ROSTRALANTERIORCINGULATE_SUVR", "CTX_RH_ROSTRALANTERIORCINGULATE_SUVR")
braak_5_rest_regs = c("CTX_LH_LATERALOCCIPITAL_SUVR", "CTX_RH_LATERALOCCIPITAL_SUVR",
                                 "CTX_LH_INFERIORPARIETAL_SUVR", "CTX_RH_INFERIORPARIETAL_SUVR",
                                 "CTX_LH_SUPERIORTEMPORAL_SUVR", "CTX_RH_SUPERIORTEMPORAL_SUVR",
                                 "CTX_LH_BANKSSTS_SUVR", "CTX_RH_BANKSSTS_SUVR",
                                 "CTX_LH_PRECUNEUS_SUVR", "CTX_RH_PRECUNEUS_SUVR",
                                 "CTX_LH_SUPERIORPARIETAL_SUVR", "CTX_RH_SUPERIORPARIETAL_SUVR",
                                 "CTX_LH_SUPRAMARGINAL_SUVR", "CTX_RH_SUPRAMARGINAL_SUVR",
                                 "CTX_LH_TRANSVERSETEMPORAL_SUVR", "CTX_RH_TRANSVERSETEMPORAL_SUVR")
braak_5_front_regs = c("CTX_LH_PARSOPERCULARIS_SUVR", "CTX_RH_PARSOPERCULARIS_SUVR",
                                 "CTX_LH_PARSORBITALIS_SUVR", "CTX_RH_PARSORBITALIS_SUVR",
                                 "CTX_LH_PARSTRIANGULARIS_SUVR", "CTX_RH_PARSTRIANGULARIS_SUVR",
                                 "CTX_LH_FRONTALPOLE_SUVR", "CTX_RH_FRONTALPOLE_SUVR",
                                 "CTX_LH_CAUDALMIDDLEFRONTAL_SUVR", "CTX_RH_CAUDALMIDDLEFRONTAL_SUVR",
                                 "CTX_LH_LATERALORBITOFRONTAL_SUVR", "CTX_RH_LATERALORBITOFRONTAL_SUVR",
                                 "CTX_LH_MEDIALORBITOFRONTAL_SUVR", "CTX_RH_MEDIALORBITOFRONTAL_SUVR",
                                 "CTX_LH_ROSTRALMIDDLEFRONTAL_SUVR", "CTX_RH_ROSTRALMIDDLEFRONTAL_SUVR",
                                 "CTX_LH_SUPERIORFRONTAL_SUVR", "CTX_RH_SUPERIORFRONTAL_SUVR")
braak_6_regs = c("CTX_LH_PERICALCARINE_SUVR", "CTX_RH_PERICALCARINE_SUVR",
                                 "CTX_LH_CUNEUS_SUVR", "CTX_RH_CUNEUS_SUVR",
                                 "CTX_LH_PARACENTRAL_SUVR", "CTX_RH_PARACENTRAL_SUVR",
                                 "CTX_LH_POSTCENTRAL_SUVR", "CTX_RH_POSTCENTRAL_SUVR",
                                 "CTX_LH_PRECENTRAL_SUVR", "CTX_RH_PRECENTRAL_SUVR")

all_braak = c(braak_1_regs, braak_3_regs, braak_4_regs, braak_5_front_regs, braak_5_rest_regs, braak_6_regs)
```


### 2. Table 1

Here, we simply need to run the CreateTableOne command, which will create the demographics table for us. We stratify by the diagnosis at baseline and the amyloid positivity status.

```{r}
data_demog <- final_data %>%
    #Select the variables we want to output
    select(DIAGNOSIS, AB_POSITIVITY_WCR, PTGENDER, apoe_bin, PTAGE, PTEDUCAT, centiloid, ADNI_MEM, ADNI_EF, ADNI_LAN,
           ADNI_VSP, max_tau_pet_number, max_cog) %>%
    #Transform the variables so the output is easier for the eyes
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                                 DIAGNOSIS == 2 ~ "MCI",
                                 DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("CU", "MCI", "AD"))) %>%
    mutate(AB_POSITIVITY_WCR = case_when(AB_POSITIVITY_WCR == 0 ~ "AB Neg",
                                         AB_POSITIVITY_WCR == 1 ~ "AB Pos")) %>%
    mutate(PTGENDER = case_when(PTGENDER == 2 ~ "Female",
                                PTGENDER == 1 ~ "Male"))

table_1 <- CreateTableOne(data=data_demog, strata=c("DIAGNOSIS", "AB_POSITIVITY_WCR")) #Create the table
#table_1
```

The one thing missing from that package is that, while they indicate which variable is significantly different, they don't specify which group is significantly different from one another. We can check this with chisquare tests and Tukey HSD tests.

```{r}
#First, create one table for each of the AB+ and AB-
demog_table_ab_neg <- data_demog %>%
    filter(AB_POSITIVITY_WCR == "AB Neg")

demog_table_ab_pos <- data_demog %>%
    filter(AB_POSITIVITY_WCR == "AB Pos")

#Print comparison significance
#demog_comp_check(demog_table_ab_pos, "AB Pos")
#demog_comp_check(demog_table_ab_neg, "AB Neg")
```

### 3. Figure 2

Figure 2 is made of two panels. The first is 3 pie charts with the proportion of AB/TAU positive participants for each diagnosis group. The second is the distribution of the probabilities of having spatial extent based on the centiloid values.

```{r}
#First, isolate and prepare the data for the pie charts
pie_chart_data <- final_data %>%
    mutate(se_status = case_when(spatial_extent_thresh_0.5 > 0 ~ 1, #When spatial extent is above 0, then positive (1)
                                 TRUE ~ 0)) %>%
    select(AB_POSITIVITY_WCR, se_status, DIAGNOSIS) %>% #Select only the columns we need
    group_by(DIAGNOSIS, AB_POSITIVITY_WCR, se_status) %>% #Group participants by diagnosis, AB status and tau status
    summarize(cnt=n()) %>% #Count the total number by each se status
    ungroup() %>%
    group_by(DIAGNOSIS) %>% #Group by diagnosis to do the %
    mutate(freq_by_ab_se = cnt / sum(cnt)) %>% #Calculate the percentage of each group
    ungroup() %>%
    unite(ab_se_group, c(AB_POSITIVITY_WCR, se_status)) %>% #Merge AB status and tau status in a single variable for plotting
    mutate(ab_se_group = fct_relevel(as.factor(ab_se_group), c("1_1", "1_0", "0_1", "0_0"))) #AT status in order (the first is AB)

pie_data_cu <- pie_chart_data %>%
    filter(DIAGNOSIS == 1) %>% #1 == CU
    mutate(cum_count_y = as.integer(cumsum(cnt))) %>% #Count the cumulative count (needed for the position on the pie chart)
    mutate(position_y = cum_count_y - (cnt*0.5)) #Find the actual position for that section of the piechart

pie_data_mci <- pie_chart_data %>%
    filter(DIAGNOSIS == 2) %>% #2 == MCI
    mutate(cum_count_y = as.integer(cumsum(cnt))) %>%
    mutate(position_y = cum_count_y - (cnt*0.5))

pie_data_ad <- pie_chart_data %>%
    filter(DIAGNOSIS == 3) %>% #3 == AD
    mutate(cum_count_y = as.integer(cumsum(cnt))) %>%
    mutate(position_y = cum_count_y - (cnt*0.5))
```

Then, create the graphs

```{r}
#Cognitively unimpaired
at_group_cu <- pie_data_cu %>%
 ggplot() +
 geom_col(aes(x=1, y=cnt, fill=ab_se_group), position = "stack") + #A pie chart is actually a one column graph + coord_polar
 #Adjust the colors to viridis for visibility and change the labels
 scale_fill_viridis_d(option="inferno", name="AT group", direction=-1, labels=c("A+T+", "A+T-", "A-T+", "A-T-")) +
 geom_text(aes(x=1.0, y=142.5, label="n=283\n(61.1%)"), color="white") + #Finding the coordinates is a bit of trial and error
 geom_text(aes(x=1.2, y=292.5, label="n=17\n(3.7%)"), color="white") +
 geom_text(aes(x=1.1, y=353.5, label="n=107\n(23.1%)"), color="white") +
 geom_text(aes(x=1.2, y=435, label="n=56\n(12.1%)"), color="black") +
 coord_polar(theta = "y") + #This is the line that transforms columns to pie chart
 theme_void() +
    ggtitle("Cognitively unimpaired") +
    theme(plot.title = element_text(face="bold", size=17, hjust = 0.5, vjust=-1))

#at_group_cu

#Mild cognitive impairment
at_group_mci <- pie_data_mci %>%
  ggplot() +
  geom_col(aes(x=1, y=cnt, fill=ab_se_group), position = "stack") +
  scale_fill_viridis_d(option="inferno", name="AT group", direction=-1, labels=c("A+T+", "A+T-", "A-T+", "A-T-")) +
  geom_text(aes(x=1.0, y=60.5, label="n=121\n(43.7%)"), color="white") +
  geom_text(aes(x=1.22, y=131, label="n=24\n(8.7%)"), color="white") +
  geom_text(aes(x=1.22, y=164.0, label="n=33\n(11.9%)"), color="white") +
  geom_text(aes(x=1.0, y=227.0, label="n=99\n(35.7%)"), color="black") +
  coord_polar(theta = "y") +
  theme_void() +
    ggtitle("Mild cognitive impairment") +
    theme(plot.title = element_text(face="bold", size=17, hjust = 0.5, vjust=-1))

#at_group_mci

#Alzheimer's disease
at_group_ad <- pie_data_ad %>%
 ggplot() +
 geom_col(aes(x=1, y=cnt, fill=ab_se_group), position = "stack") +
 scale_fill_viridis_d(option="inferno", name="AT group", direction=-1, labels=c("A+T+", "A+T-", "A-T+", "A-T-")) +
 #scale_fill_manual(values=c("#FDFDA4","#EE6924","#FBFBFB","#FBFBFB"), name="AT group", labels=c("A+T+", "A+T-", "A-T+", "A-T-")) + #Merged AB- stats in grey
 geom_text(aes(x=1.24, y=4.3, label="n=10\n(10.9%)"), color="white") +
 geom_text(aes(x=1.24, y=12.5, label="n=5\n(5.4%)"), color="white") +
 geom_text(aes(x=1.24, y=20, label="n=9\n(9.8%)"), color="white") +
 geom_text(aes(x=1.0, y=58.0, label="n=68\n(73.9%)"), color="black") +
 coord_polar(theta = "y") +
 theme_void() +
    ggtitle("Alzheimer's disease") +
    theme(plot.title = element_text(face="bold", size=17, hjust = 0.5, vjust=-1))

#at_group_ad

#Patch the plots together
#pie_patch <- (at_group_cu + at_group_mci + at_group_ad + plot_layout(guides = "collect") / )

#Save the plot
#ggsave(glue("{figure_space}/figure2a_raw.png"), plot=pie_patch, height=4, width = 12, dpi=500)
```

For panel B, we first compute the logistic regression, and then plot the data.

```{r}
#Isolate the data needed for this analysis
log_regress_spex_ab <- final_data %>%
    mutate(se_status = case_when(spatial_extent_thresh_0.5 > 0 ~ 1, #Create the positivity
                                 TRUE ~ 0)) %>%
    select(AB_POSITIVITY_WCR, se_status, DIAGNOSIS, centiloid) #Keep only main variables

#Do the logistic regression
glm_bin_spex_ab <- glm(se_status ~ centiloid, data=log_regress_spex_ab, family="binomial") #Do the logistic regression
log_regress_spex_ab$prob_spex_cent <- glm_bin_spex_ab$fitted.values #Extract the predicted values from the GLM
# summary(glm_bin_spex_ab) #To get the log odds and significance
```

```{r}
#Plot the logistic regression data (probability of spex by amount of centiloid)

plot_prob_spex_by_centiloid <- log_regress_spex_ab %>%
  ggplot(aes(x=centiloid, y=prob_spex_cent)) + #Plot the centiloid against the probability of spex
  #Create a jitter of points for visualization
  geom_jitter(aes(color=as.factor(DIAGNOSIS), shape=as.factor(se_status)), height=0.065, width=0.065, alpha=0.6) +
  geom_hline(yintercept=0.5, linetype="dashed") + #A line at 50% for visualization
  scale_shape_manual(values=c(25, 19), labels=c("No", "Yes"), name="Spatial Extent \nIndex >=1") + #Shape by the positivity of tau
  #color by the diagnosis
  scale_color_manual(values = c("#44C8F5", "#F7941D", "#ED1B2F"), labels=c("CU", "MCI", "AD"), name="Diagnostic\nstatus") +
  annotate("text", y=-Inf, x =125, hjust=0, vjust=-1, #Just add some text on the odds ratios
           label="Odds ratio: 1.04047 ***") +
  theme_classic() +
  theme(panel.grid.major = element_line(), #Reimports the axis grid (1/2)
          panel.grid.minor = element_line(), #Reimports the axis gris (1/2)
          text = element_text(size=14, family="sans"), #Imposes font family and size
          axis.title.x = element_text(face="bold"), #Bolds the axis title
          axis.title.y = element_text(face="bold")) +
  xlab("Centiloid values") +
  ylab("Probability of having\nSpatial Extent")

#plot_prob_spex_by_centiloid


#Patch the plots together
thm <- theme(plot.title = element_text(face = 2, size=18, hjust=0))

pie_patch <- (wrap_elements(
    (at_group_cu + at_group_mci + at_group_ad + plot_layout(guides = "collect") + plot_annotation(title='A', theme=thm))))

new_centiloid_plot <- wrap_elements(plot_prob_spex_by_centiloid + plot_annotation(title='B', theme=thm))

figure_2 <- pie_patch / new_centiloid_plot

#Save the plot
ggsave(glue("{figure_space}/figure2_raw.png"), plot=figure_2, height=8, width = 12, dpi=500)

#ggsave(glue("{figure_space}/figure2b_raw.png"), plot=plot_prob_spex_by_centiloid, width=8, height=4, units='in', dpi=500)

```

### 4. Figure 3

Figure 3 is a delicate (and difficult) figure to reproduce, necessiting a lot of data transformation and manual graph adjustment.

The first part is the heatmap. The Braak heatmap and the SUVR heatmap are in separate pieces

```{r}
#Finding the variables on the participants that should be included in the analysis
ids_index <- final_data %>%
    select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5) %>% #Only keep variables we need
    #Transform the numbers to factors, which makes it easier to deal with when arranging them.
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(AB_POSITIVITY_WCR = as.factor(case_when(AB_POSITIVITY_WCR == 0 ~ "AB-",
                                         AB_POSITIVITY_WCR == 1 ~ "AB+")))

#Import binary masks 
mask_regional_se_gmm <- read_csv(glue("{project_space}/long_spex_gmm_mask.csv")) 
mask_regional_se_gmm_bl<- mask_regional_se_gmm %>%
    filter(tau_pet_number == 1) %>% #Keep only baselines
    select(-c(EXAMDATE_tau, tau_pet_number)) %>% #Remove examdate and tau_pet_number (no longer useful)
    left_join(ids_index) %>% #Merge the DX, AB and tau status which we need to sort and classify
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("AD", "MCI", "CU"))) %>% #Relevel the factors in the order we want
    mutate(AB_POSITIVITY_WCR = fct_relevel(AB_POSITIVITY_WCR, c("AB-", "AB+"))) %>%
    group_by(DIAGNOSIS, AB_POSITIVITY_WCR) %>% #We group by diagnosis and AB positivity status
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, -spatial_extent_thresh_0.5) %>% #We arrange participants by diagnosis, positivity and spatial extent (this last one, from highest to lowest to the bars all go to the bottom of each section)
    #Pivot to a long format. This is needed for ggplot to understand that the regions are the x-axis of the heatmap
    pivot_longer(cols = -c(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), names_to="regions", values_to = "spex") %>%
    mutate(regions = as.factor(regions)) %>% #Make regions as factor
    mutate(regions = fct_relevel(regions, all_braak)) %>% #Make sure regions are in the Braak order
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, regions, -spatial_extent_thresh_0.5) %>% #Final sort, making sure the regions will show up in Braak order
    ungroup()

#Repeat the same process for the Braak stages
#Import binary masks
mask_braak_se_gmm <- read_csv(glue("{project_space}/long_spex_gmm_braak_mask.csv")) 
mask_braak_se_gmm_bl <- mask_braak_se_gmm %>%
    select(-meta_roi_tau_jack) %>%
    filter(tau_pet_number == 1) %>%
    select(-c(EXAMDATE_tau, tau_pet_number)) %>%
    left_join(ids_index) %>%
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("AD", "MCI", "CU"))) %>%
    mutate(AB_POSITIVITY_WCR = fct_relevel(AB_POSITIVITY_WCR, c("AB-", "AB+"))) %>%
    group_by(DIAGNOSIS, AB_POSITIVITY_WCR) %>%
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, -spatial_extent_thresh_0.5) %>%
    pivot_longer(cols = -c(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), names_to="regions", values_to = "spex") %>%
    mutate(regions = as.factor(regions)) %>%
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, regions, -spatial_extent_thresh_0.5) %>%
    ungroup()

```

```{r}
#Create the heatmap for AB+ participants
heat_map_braak_ab_pos <- mask_braak_se_gmm_bl %>%
  mutate(RID = fct_inorder(as.factor(RID))) %>% #Order the RIDs
  filter(AB_POSITIVITY_WCR == "AB+") %>% #Keep only AB+ participants
  ggplot(aes(y=RID, x=regions, fill=as.factor(spex))) +
  geom_tile() + #A heatmap can be plotted with geom_tile()
  theme_classic() + #Remove the axis in the back of the plot
  scale_fill_manual(values = c("#024F6D", "#FDE725"), labels=c("Negative", "Positive"), name="Regional positivity\nstatus") + #Turn negativity/positivity to Navy and Yellow
    #Each of the lines below require manual adjustments. If the number of participants change, you will need to change the numbers for the figure to be looking ok.
    #The only coordinates you should need to change is the y and yend
  annotate("segment", x=0.15, xend=0.15, y=1, yend=77, color="#ed1b2f") + #This will make a line to the left of the graph to designate AD participants
  annotate("Text", x=-0.2, y=35, angle=90, label='AD A\U03B2+', color="#ed1b2f") + #This will label the line for AD participants
  annotate("segment", x=0.15, xend=0.15, y=78, yend=209, color="#F7941D") +
  annotate("Text", x=-0.2, y=143, angle=90, label='MCI A\U03B2+', color="#F7941D") +
  annotate("segment", x=0.15, xend=0.15, y=210, yend=372, color="#44C8F5") +
  annotate("Text", x=-0.2, y=280, angle=90, label='CU A\U03B2+', color="#44C8F5") +
    #Label the Braak stages properly
  scale_x_discrete(labels=c("I", "III", "IV", "V", "VI")) +
  ylab("Participants \n(by diagnosis)") +
  xlab("Regions") +
  coord_cartesian(clip="off") + #This is to make sure the writings for each group are not cutoff by ggplot on the left side
  theme(axis.text.y = element_blank(), #Remove axis test for Y (we don't need the individual RIDs)
        axis.ticks.y = element_blank(), #Remove the ticks for Y (we don't need to know that each line is an RID, we can see that from the graph)
        line = element_blank(), #Remove the lines in the graph
        axis.title.y = element_text(vjust=2.5, face="bold", size=14), #Changes the title of the Y axis
        text = element_text(family="sans"), #Imposes font family and size
        axis.title.x = element_text(face="bold", size=14),
        axis.text.x = element_text(size = 12),
        legend.position = "none") #Removes the legend (we will have it on the cortical heatmap)

#Repeat the same steps for the cortical regions, with only a few differences
heat_map_ab_pos <- mask_regional_se_gmm_bl %>%
  mutate(RID = fct_inorder(as.factor(RID))) %>%
  filter(AB_POSITIVITY_WCR == "AB+") %>%
  ggplot(aes(y=RID, x=regions, fill=as.factor(spex))) +
  geom_tile() +
  theme_classic() +
  scale_fill_manual(values = c("#024F6D", "#FDE725"), labels=c("Negative", "Positive"), name="Regional positivity\nstatus") +
  annotate("segment", x=0.15, xend=0.15, y=1, yend=77, color="#ed1b2f") +
  annotate("Text", x=-0.5, y=35, angle=90, label='AD A\U03B2+', color="#ed1b2f", size=4) +
  annotate("segment", x=0.15, xend=0.15, y=78, yend=209, color="#F7941D") +
  annotate("Text", x=-0.5, y=143, angle=90, label='MCI A\U03B2+', color="#F7941D", size=4) +
  annotate("segment", x=0.15, xend=0.15, y=210, yend=372, color="#44C8F5") +
  annotate("Text", x=-0.5, y=280, angle=90, label='CU A\U03B2+', color="#44C8F5", size=4) +
    #We want a line separating each of the Braak stages
  geom_vline(xintercept = 2.5, color="black") +
  geom_vline(xintercept = 10.5, color="black") +
  geom_vline(xintercept = 26.5, color="black") +
  geom_vline(xintercept = 58.5, color="black") +
  geom_vline(xintercept = 42.5, color="black", linetype="dashed") + #This one is dashed because we split Braak V
                                                                    # arbitrarily between Frontal regions and the rest
  #Label each section with the right Braak stage
  annotate("text", x=1.5, y=-3, label="I", size=4) +
  annotate("text", x=6, y=-3, label="III", size=4) +
  annotate("text", x=18, y=-3, label="IV", size=4) +
  annotate("text", x=34, y=-3, label="V - Parietal", size=4) +
  annotate("text", x=50, y=-3, label="V - Frontal", size=4) +
  annotate("text", x=64, y=-3, label="VI", size=4) +
  coord_cartesian(clip="off") +
  xlab("Regions") +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        line = element_blank(),
        axis.title.y = element_blank(),
        axis.title.x = element_text(vjust=-0.2, face="bold", size=14),
        legend.text = element_text(size=10),
        legend.title = element_text(size=12))

thm <- theme(plot.title = element_text(face = 2, size = 20))
patch_heatmap_ab_pos <- wrap_elements(
    (heat_map_braak_ab_pos + heat_map_ab_pos + plot_layout(widths = c(1.5, 12))) 
    + plot_annotation(title='A', theme=thm)) #Fit the Braak and cortical graphs together in one plot

# ggsave(glue("{figure_space}/figure3a_raw.png"), plot=patch_heatmap_ab_pos, width = 14.5, height = 8, units="in", dpi=500) #Output
#Note: if you change anything about the size of the graph (e.g., nb of participants) you will need to play with the dimensions here
```

Finally, we want to compute the porportion of people following the Braak stages (if positive on III, then is also positive on I).

```{r}
follow_braak_cs <- mask_braak_se_gmm_bl %>%
    filter(AB_POSITIVITY_WCR == "AB+") %>% #Keep only AB+
    pivot_wider(id_cols=c(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), names_from = regions, values_from=spex) %>% #Pivot the long dataframe to wide (easier to set conditions)
    select(-c(AB_POSITIVITY_WCR, spatial_extent_thresh_0.5)) #Remove extraneous variables

#Calculate the Braak staging following (first all 6, then drop by 1 each time)
follow_braak_cs %>% filter(braak6_suvr == 1) %>% mutate(follows = case_when(
    braak5_suvr == 1 & braak4_suvr == 1 & braak3_suvr == 1 & braak1_suvr == 1 ~ "follows",
    TRUE ~ 'no'
)) %>% mutate(n = n()) %>% group_by(follows) %>% summarise(count = n() / nrow(.) ) #79.3% follows

follow_braak_cs %>% filter(braak5_suvr == 1) %>% mutate(follows = case_when(
    braak4_suvr == 1 & braak3_suvr == 1 & braak1_suvr == 1 ~ "follows",
    TRUE ~ 'no'
)) %>% mutate(n = n()) %>% group_by(follows) %>% summarise(count = n() / nrow(.) ) #95.6% follows

follow_braak_cs %>% filter(braak4_suvr == 1) %>% mutate(follows = case_when(
    braak3_suvr == 1 & braak1_suvr == 1 ~ "follows",
    TRUE ~ 'no'
)) %>% mutate(n = n()) %>% group_by(follows) %>% summarise(count = n() / nrow(.) ) #91.5% follows

follow_braak_cs %>% filter(braak3_suvr == 1) %>% mutate(follows = case_when(
    braak1_suvr == 1 ~ "follows",
    TRUE ~ 'no'
)) %>% mutate(n = n()) %>% group_by(follows) %>% summarise(count = n() / nrow(.) ) #99.0% follows


```


#### Figure 3B and C

Panels B and C of Figure 3 are brain templates we make using ggseg. We will be reusing the same index for both graphs, so we can create the index here.

```{r}
# The format of the data cleaning is similar to the heatmaps, but we need to isolate the data from each diagnosis.
#Finding the variables on the participants that should be included in the analysis
ids_index <- final_data %>%
    select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5) %>% #Only keep variables we need
    #Transform the numbers to factors, which makes it easier to deal with when arranging them.
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(AB_POSITIVITY_WCR = as.factor(case_when(AB_POSITIVITY_WCR == 0 ~ "AB-",
                                         AB_POSITIVITY_WCR == 1 ~ "AB+")))
```

The only difference between figures B and C is the type of measurement. In B, we use the SUVR average in each brain region for each diagnostic group.

Let's start with Panel B.

```{r}
#Import binary masks 
mask_map_regional_suvr <- read_csv(glue("{project_space}/suvr_values_long.csv")) 
mask_map_regional_suvr_bl <- mask_map_regional_suvr %>%
    filter(tau_pet_number == 1) %>% #Keep only baselines
    select(-c(EXAMDATE_tau, tau_pet_number)) %>% #Remove examdate and tau_pet_number (no longer useful)
    left_join(ids_index) %>% 
    filter(AB_POSITIVITY_WCR == "AB+") %>%
    select(-RID, -AB_POSITIVITY_WCR, -spatial_extent_thresh_0.5)

#Compute the sums for each diagnostic group

suvr_roi_cu <- roi_summarize_bl(data=mask_map_regional_suvr_bl, DIAG="CU")
suvr_roi_mci <- roi_summarize_bl(data=mask_map_regional_suvr_bl, DIAG="MCI")
suvr_roi_ad <- roi_summarize_bl(data=mask_map_regional_suvr_bl, DIAG="AD")

#min(spex_roi_cu$brain_val) #To figure out the limits of the plot, we need the minimum % 
#max(spex_roi_ad$brain_val) #To figure out the limits of the plot, we ned the maximum %
#Note: depending on the positivity, we might need to check all groups to ensure we got it right.

min(suvr_roi_cu$brain_val)
max(suvr_roi_cu$brain_val)
min(suvr_roi_mci$brain_val)
max(suvr_roi_mci$brain_val)

ggseg_suvr_cu_bl <- brain_template_plotting(suvr_roi_cu, c(0.98, 1.80), legend_name="Average\nSUVR", plot_name="Cognitively\nUnimpaired A\U03B2+")
ggseg_suvr_mci_bl <- brain_template_plotting(suvr_roi_mci, c(0.98, 1.80), legend_name="Average\nSUVR", plot_name="Mild Cognitive\nImpairment A\U03B2+")
ggseg_suvr_ad_bl <- brain_template_plotting(suvr_roi_ad,c(0.98, 1.80), legend_name="Average\nSUVR", plot_name="Alzheimer's\ndisease A\U03B2+")

ggseg_suvr_bl <- wrap_elements((ggseg_suvr_cu_bl + ggseg_suvr_mci_bl + ggseg_suvr_ad_bl + plot_layout(guides = "collect") & theme(legend.position = 'bottom', plot.margin = unit(c(0,0,0,0), "cm"))) + plot_annotation(title = "B", theme=thm))

#ggsave(glue("{figure_space}/figure3b_raw.png", plot=ggseg_suvr_bl), width = 15, height = 6, dpi=500)
```


Now we repeat the operations for Figure 3C

```{r}
#Import binary masks 
mask_map_regional_se_gmm <- read_csv(glue("{project_space}/long_spex_gmm_mask.csv")) 
mask_map_regional_se_gmm_bl<- mask_map_regional_se_gmm %>%
    filter(tau_pet_number == 1) %>% #Keep only baselines
    select(-c(EXAMDATE_tau, tau_pet_number)) %>% #Remove examdate and tau_pet_number (no longer useful)
    left_join(ids_index) %>% 
    filter(AB_POSITIVITY_WCR == "AB+") %>%
    select(-RID, -AB_POSITIVITY_WCR, -spatial_extent_thresh_0.5)

#Compute the sums for each diagnostic group

spex_roi_cu <- roi_summarize_bl(data=mask_map_regional_se_gmm_bl, DIAG="CU", SIZE=163)
spex_roi_mci <- roi_summarize_bl(data=mask_map_regional_se_gmm_bl, DIAG="MCI", SIZE=132)
spex_roi_ad <- roi_summarize_bl(data=mask_map_regional_se_gmm_bl, DIAG="AD", SIZE=77)

#min(spex_roi_cu$brain_val) #To figure out the limits of the plot, we need the minimum % 
#max(spex_roi_ad$brain_val) #To figure out the limits of the plot, we ned the maximum %
#Note: depending on the positivity, we might need to check all groups to ensure we got it right.

min(spex_roi_cu$brain_val)
max(spex_roi_cu$brain_val)
min(spex_roi_mci$brain_val)
max(spex_roi_mci$brain_val)
min(spex_roi_ad$brain_val)
max(spex_roi_ad$brain_val)

ggseg_spex_cu_bl <- brain_template_plotting(spex_roi_cu, c(0,76), legend_name="% of positive\n participants", plot_name="Cognitively\nUnimpaired A\U03B2+")
ggseg_spex_mci_bl <- brain_template_plotting(spex_roi_mci, c(0,76), legend_name="% of positive\n participants", plot_name="Mild Cognitive\nImpairment A\U03B2+")
ggseg_spex_ad_bl <- brain_template_plotting(spex_roi_ad, c(0,76), legend_name="% of positive\n participants", plot_name="Alzheimer's\ndisease A\U03B2+")

ggseg_spex_bl <- wrap_elements((ggseg_spex_cu_bl + ggseg_spex_mci_bl + ggseg_spex_ad_bl + plot_layout(guides = "collect") & theme(legend.position = 'bottom', plot.margin = unit(c(0,0,0,0), "cm"))) + plot_annotation(title='C', theme=thm))

#ggsave(glue("{figure_space}/figure3c_raw.png", plot=ggseg_spex_bl), width = 15, height = 6, dpi=500)
```

```{r}
#Output final figure 3 with patchwork

figure3 <- (patch_heatmap_ab_pos / ggseg_suvr_bl / ggseg_spex_bl) + plot_layout(heights = c(10, 6, 6), widths = c(15, 6, 6))


ggsave(glue("{figure_space}/figure3_raw.png"), plot=figure3, width = 11.2, height = 16, dpi=500)
```



```{r}
#Reviewer - CU with min/max scale of CU
max(spex_roi_cu$brain_val)

ggseg_spex_cu_bl <- brain_template_plotting(spex_roi_cu, c(0, 18), legend_name="% of positive\n participants", plot_name="Cognitively\nUnimpaired A\U03B2+")

ggsave(glue("{figure_space}/suppfigure14_raw.png", plot=ggseg_spex_cu_bl), width = 5, height = 6, dpi=500)
```


### 5. Figure 4

Figure 4 is identical to figure 3, but instead looking at longitudinal visits. For simplicity of the visualizations--and because statistical significance is calculated differently--we considered only the first and last visit for each participant.

#### 5.1 Figure 4a

```{r}
#Finding the variables on the participants that should be included in the analysis
ids_index <- final_data %>%
    select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5) %>% #Only keep variables we need
    #Transform the numbers to factors, which makes it easier to deal with when arranging them.
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(AB_POSITIVITY_WCR = as.factor(case_when(AB_POSITIVITY_WCR == 0 ~ "AB-",
                                         AB_POSITIVITY_WCR == 1 ~ "AB+")))

#Import binary masks
mask_regional_se_gmm <- read_csv(glue("{project_space}/long_spex_gmm_mask.csv")) 
mask_regional_se_gmm_long <- mask_regional_se_gmm %>%
    group_by(RID) %>% #We want longitudinal, so we need to figure out longitudinal visits for each RID
    filter(n_distinct(tau_pet_number) >= 2) %>% #Keep only people with 2 or more visits
    filter(row_number() == 1 | row_number()==n()) %>% #For each participant, keep the first and last row
    select(-c(EXAMDATE_tau)) %>% #Removing useless column
    left_join(ids_index) %>% #Merge the diagnosis and amyloid positivity information
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("AD", "MCI", "CU"))) %>% #Relevel diagnoses so AD will be at the bottom and AD at the top of the heatmap
    mutate(AB_POSITIVITY_WCR = fct_relevel(AB_POSITIVITY_WCR, c("AB-", "AB+"))) %>% #Relevel AB positivity so AB+ are together
    #Next, we pivot to a long format
    pivot_longer(cols = -c(RID, DIAGNOSIS, tau_pet_number, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), names_to="regions", values_to = "posit") %>%
    mutate(first_last_tag = ifelse(tau_pet_number == 1, "First", "Last")) %>% #For each participant, we tag the first observation as "First" and the second as "Last"
    #Next, we need to flip back to a wide format, so for each region, of each individual, we have the score for the first and last visit in two columns
    pivot_wider(id_cols = c(RID, regions, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), values_from = c(posit), names_from = c(first_last_tag)) %>%
    #We substract the first and last visits to get the conversion status
    mutate(first_minus_last = First - Last) %>%
    #Next, we change the "first_minus_last" to a proper conversion variable
    mutate(conversion = case_when(first_minus_last == 1 ~ "Pos_to_neg", #1 - 0 = 1
                                  first_minus_last == -1 ~ "Neg_to_pos", #0 - 1 = -1
                                  first_minus_last == 0 & First == 0 ~ "Stab_neg", #0 - 0 = 0, so we need to precise that the first visit is negative
                                  first_minus_last == 0 & Last == 1 ~ "Stab_pos")) %>% #1 - 1 = 0, so we need to precise that the last visit is positive
    mutate(regions = as.factor(regions)) %>%
    mutate(regions = fct_relevel(regions, all_braak)) %>%
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, regions, -spatial_extent_thresh_0.5) %>%
    ungroup()

#Repeat the process for Braak stages
mask_braak_se_gmm <- read_csv(glue("{project_space}/long_spex_gmm_braak_mask.csv")) 
mask_braak_se_gmm_long <- mask_braak_se_gmm %>%
    group_by(RID) %>% #We want longitudinal, so we need to figure out longitudinal visits for each RID
    select(-c(meta_roi_tau_jack)) %>% #Remove the meta-ROI: we only want the Braak stages
    filter(n_distinct(tau_pet_number) >= 2) %>% #Keep only people with 2 or more visits
    filter(row_number() == 1 | row_number()==n()) %>% #For each participant, keep the first and last row
    select(-c(EXAMDATE_tau)) %>% #Removing useless column
    left_join(ids_index) %>% #Merge the diagnosis and amyloid positivity information
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("AD", "MCI", "CU"))) %>% #Relevel diagnoses so AD will be at the bottom and AD at the top of the heatmap
    mutate(AB_POSITIVITY_WCR = fct_relevel(AB_POSITIVITY_WCR, c("AB-", "AB+"))) %>% #Relevel AB positivity so AB+ are together
    #Next, we pivot to a long format
    pivot_longer(cols = -c(RID, DIAGNOSIS, tau_pet_number, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), names_to="regions", values_to = "posit") %>%
    mutate(first_last_tag = ifelse(tau_pet_number == 1, "First", "Last")) %>% #For each participant, we tag the first observation as "First" and the second as "Last"
    #Next, we need to flip back to a wide format, so for each region, of each individual, we have the score for the first and last visit in two columns
    pivot_wider(id_cols = c(RID, regions, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), values_from = c(posit), names_from = c(first_last_tag)) %>%
    #We substract the first and last visits to get the conversion status
    mutate(first_minus_last = First - Last) %>%
    #Next, we change the "first_minus_last" to a proper conversion variable
    mutate(conversion = case_when(first_minus_last == 1 ~ "Pos_to_neg", #1 - 0 = 1
                                  first_minus_last == -1 ~ "Neg_to_pos", #0 - 1 = -1
                                  first_minus_last == 0 & First == 0 ~ "Stab_neg", #0 - 0 = 0, so we need to precise that the first visit is negative
                                  first_minus_last == 0 & Last == 1 ~ "Stab_pos")) %>% #1 - 1 = 0, so we need to precise that the last visit is positive
    mutate(regions = as.factor(regions)) %>%
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, regions, -spatial_extent_thresh_0.5) %>%
    ungroup()
```

Now that these preparations are done, the data is ready to plot. We will plot for Braak stages and for regions, and then patch them together. The code is nearly identical to Figure 3A, with the exception of the extra coloring.

```{r}
#From here, the code is the same as Figure 3A, excepted for the "scale_fill_manual" function.
heat_map_braak_long <- mask_braak_se_gmm_long %>%
  mutate(RID = fct_inorder(as.factor(RID))) %>%
  filter(AB_POSITIVITY_WCR == "AB+") %>%
  ggplot(aes(y=RID, x=regions, fill=as.factor(conversion))) +
  geom_tile() +
  theme_classic() + 
  scale_fill_manual(values = c("red", "#44C8F5", "#024F6D", "yellow"), labels=c("Progressors", "Regressors", "Stable negative", "Stable positive"), name="Tau progression status") +
  annotate("segment", x=0.15, xend=0.15, y=1, yend=39, color="#ed1b2f") +
  annotate("Text", x=-0.5, y=19, angle=90, label='AD A\U03B2+', color="#ed1b2f") +
  annotate("segment", x=0.15, xend=0.15, y=40, yend=105, color="#F7941D") +
  annotate("Text", x=-0.5, y=75, angle=90, label='MCI A\U03B2+', color="#F7941D") +
  annotate("segment", x=0.15, xend=0.15, y=106, yend=195, color="#44C8F5") +
  annotate("Text", x=-0.5, y=140, angle=90, label='CU A\U03B2+', color="#44C8F5") +
  #geom_vline(xintercept = 1.5, linetype="dashed", color="black") +
  scale_x_discrete(labels=c("I", "III", "IV", "V", "VI")) +
  ylab("Participants \n(by diagnosis)") +
  xlab("Regions") +
  coord_cartesian(clip="off") +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        line = element_blank(),
        axis.title.y = element_text(vjust=2.5, face="bold", size=14),
        text = element_text(family="sans"), #Imposes font family and size
        axis.title.x = element_text(face="bold", size=14),
        legend.position = "none")

#Code is the same as Figure 3A excepted for the "scale_fill_manual" function
heat_map_long <- mask_regional_se_gmm_long %>%
  mutate(RID = fct_inorder(as.factor(RID))) %>%
  filter(AB_POSITIVITY_WCR == "AB+") %>%
  ggplot(aes(y=RID, x=regions, fill=as.factor(conversion))) +
  geom_tile() +
  theme_classic() +
  scale_fill_manual(values = c("red", "#44C8F5", "#024F6D", "yellow"), 
                    labels=c("Progressors", "Regressors","Stable negative", "Stable positive"), 
                    name="Tau progression status") +
  annotate("segment", x=0.15, xend=0.15, y=1, yend=39, color="#ed1b2f") +
  annotate("Text", x=-0.5, y=19, angle=90, label='AD A\U03B2+', color="#ed1b2f") +
  annotate("segment", x=0.15, xend=0.15, y=40, yend=105, color="#F7941D") +
  annotate("Text", x=-0.5, y=75, angle=90, label='MCI A\U03B2+', color="#F7941D") +
  annotate("segment", x=0.15, xend=0.15, y=106, yend=195, color="#44C8F5") +
  annotate("Text", x=-0.5, y=140, angle=90, label='CU A\U03B2+', color="#44C8F5") +
  geom_vline(xintercept = 2.5, color="black") +
  geom_vline(xintercept = 10.5, color="black") +
  geom_vline(xintercept = 26.5, color="black") +
  geom_vline(xintercept = 58.5, color="black") +
  geom_vline(xintercept = 42.5, color="black", linetype="dashed") +
  annotate("text", x=1.5, y=-1.5, label="I", size=4) +
  annotate("text", x=6, y=-1.5, label="III", size=4) +
  annotate("text", x=18, y=-1.5, label="IV", size=4) +
  annotate("text", x=34, y=-1.5, label="V - Parietal", size=4) +
  annotate("text", x=50, y=-1.5, label="V - Frontal", size=4) +
  annotate("text", x=64, y=-1.5, label="VI", size=4) +
  coord_cartesian(clip="off") +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        line = element_blank(),
        axis.title.y = element_blank(),
        axis.title.x = element_text(vjust=-0.2, face="bold", size=14),
        legend.text = element_text(size=12),
        legend.title = element_text(size=14)) +
  xlab("Regions")

thm <- theme(plot.title = element_text(face = 2, size = 20))
patch_heatmap_ab_pos_long <- wrap_elements(
    (heat_map_braak_long + heat_map_long + plot_layout(widths = c(1.5, 12))) 
    + plot_annotation(title='A', theme=thm))

#patch_heatmap_ab_pos_long <- heat_map_braak_long + heat_map_long + plot_layout(widths = c(1.5, 12)) #Fit the Braak and cortical graphs together in one plot

#ggsave(glue("{figure_space}/figure4a_raw.png"), plot=patch_heatmap_ab_pos_long, width = 14.5, height = 8, units="in", dpi=500)
```

```{r}
#Same as baseline showed for Figure 3
follow_braak_cs <- mask_braak_se_gmm_long %>%
    filter(AB_POSITIVITY_WCR == "AB+") %>%
    pivot_wider(id_cols=c(RID, DIAGNOSIS, AB_POSITIVITY_WCR), names_from = regions, values_from=conversion) %>%
    select(-c(AB_POSITIVITY_WCR))


follow_braak_cs %>% filter(braak6_suvr == "Neg_to_pos") %>% mutate(follows = case_when(
    (braak5_suvr == "Neg_to_pos" | braak5_suvr == "Stab_pos") & (braak4_suvr == "Neg_to_pos" | braak4_suvr == "Stab_pos") & (braak3_suvr == "Neg_to_pos" | braak3_suvr == "Stab_pos") & (braak1_suvr == "Neg_to_pos" | braak1_suvr == "Stab_pos") ~ "follows",
    TRUE ~ 'no'
)) %>% mutate(n = n()) %>% group_by(follows) %>% summarise(count = n() / nrow(.) ) #60% follows

follow_braak_cs %>% filter(braak5_suvr == "Neg_to_pos") %>% mutate(follows = case_when(
    (braak4_suvr == "Neg_to_pos" | braak4_suvr == "Stab_pos") & (braak3_suvr == "Neg_to_pos" | braak3_suvr == "Stab_pos") & (braak1_suvr == "Neg_to_pos" | braak1_suvr == "Stab_pos") ~ "follows",
    TRUE ~ 'no'
)) %>% mutate(n = n()) %>% group_by(follows) %>% summarise(count = n() / nrow(.) ) #78.6% follows

follow_braak_cs %>% filter(braak4_suvr == "Neg_to_pos") %>% mutate(follows = case_when(
    (braak3_suvr == "Neg_to_pos" | braak3_suvr == "Stab_pos") & (braak1_suvr == "Neg_to_pos" | braak1_suvr == "Stab_pos") ~ "follows",
    TRUE ~ 'no'
)) %>% mutate(n = n()) %>% group_by(follows) %>% summarise(count = n() / nrow(.) ) #91.6% follows

follow_braak_cs %>% filter(braak3_suvr == "Neg_to_pos") %>% mutate(follows = case_when(
    (braak1_suvr == "Neg_to_pos" | braak1_suvr == "Stab_pos") ~ "follows",
    TRUE ~ 'no'
)) %>% mutate(n = n()) %>% group_by(follows) %>% summarise(count = n() / nrow(.) ) #100% follows
```


#### 5.2 Figure 4B and C

Same here: these figures are identical to Figure 3B and C

```{r}
# The format of the data cleaning is similar to the heatmaps, but we need to isolate the data from each diagnosis.
#Finding the variables on the participants that should be included in the analysis
ids_index <- final_data %>%
    select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5) %>% #Only keep variables we need
    #Transform the numbers to factors, which makes it easier to deal with when arranging them.
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(AB_POSITIVITY_WCR = as.factor(case_when(AB_POSITIVITY_WCR == 0 ~ "AB-",
                                         AB_POSITIVITY_WCR == 1 ~ "AB+"))) %>%
    inner_join(meta_roi_time_calc %>% select(RID, EXAMDATE_tau, tau_pet_number, cum_meta_roi_years))
    

```

```{r}
#First, we need to import the SUVR data in each brain region
mask_map_regional_suvr <- read_csv(glue("{project_space}/suvr_values_long.csv")) 
mask_map_regional_suvr_long <- mask_map_regional_suvr %>%
  left_join(ids_index, by=c("RID", "EXAMDATE_tau", "tau_pet_number")) %>% #Merge the SUVR values to the demographic information for each participant
  filter(AB_POSITIVITY_WCR == "AB+") %>% #Restrict to AB+ participants
  group_by(RID) %>% #Group by ID so the next filter affects individual participants
    #The next two lines keep participants with exactly 3 visits. This is to get the same sample size for each visit so the LME makes sense
  filter(tau_pet_number <= 3) %>% 
  filter(n_distinct(tau_pet_number) >= 3) %>%
  ungroup() %>% #We don't need the grouping anymore
  select(-RID, -AB_POSITIVITY_WCR, -EXAMDATE_tau, -spatial_extent_thresh_0.5) #We don't need these variables going forward
```


```{r}
suvr_cu_long <- region_wise_slopes(mask_map_regional_suvr_long, DIAG="CU", SIZE=NA) #Computes the region-wise SUVR slopes for the CU group.
suvr_mci_long <- region_wise_slopes(mask_map_regional_suvr_long, DIAG="MCI", SIZE=NA)
suvr_ad_long <- region_wise_slopes(mask_map_regional_suvr_long, DIAG="AD", SIZE=NA)

#Plot the SUVR slopes in each brain region
ggseg_suvr_cu_long <- brain_template_plotting_long(suvr_cu_long, limits_y=c(-0.002, 0.06), legend_name="Average annual\nSUVR change", plot_name="Cognitively\nUnimpaired A\U03B2+") #Plots the 
ggseg_suvr_mci_long <- brain_template_plotting_long(suvr_mci_long, limits_y=c(-0.002, 0.06), legend_name="Average annual\nSUVR change", plot_name="Mild Cognitive\nImpairment A\U03B2+")
ggseg_suvr_ad_long <- brain_template_plotting_long(suvr_ad_long, limits_y=c(-0.002, 0.06), legend_name="Average annual\nSUVR change", plot_name="Alzheimer's\ndisease A\U03B2+")

#Patch the plots together

ggseg_suvr_long <- wrap_elements((ggseg_suvr_cu_long + ggseg_suvr_mci_long + ggseg_suvr_ad_long + plot_layout(guides = "collect") & theme(legend.position = 'bottom', plot.margin = unit(c(0,0,0,0), "cm"))) + plot_annotation(title = "B", theme=thm))

#ggseg_suvr_long <- ggseg_suvr_cu_long + ggseg_suvr_mci_long + ggseg_suvr_ad_long + plot_layout(guides = "collect") & theme(legend.position = 'bottom')

#ggsave(glue("{figure_space}/figure4b_raw.png", plot=ggseg_suvr_long), width = 15, height = 6, dpi=500) #save

```

```{r}
#Reviewer comment
max(suvr_cu_long$regional_long_change_tau)
ggseg_suvr_cu_long <- brain_template_plotting_long(suvr_cu_long, limits_y=c(-0.002, 0.025), legend_name="Average annual\nSUVR change", plot_name="Cognitively\nUnimpaired A\U03B2+")

ggsave(glue("{figure_space}/suppfigX9_raw.png", plot=ggseg_suvr_cu_long), width = 5, height = 6, dpi=500) #save
```


```{r}
#Repeat the same process as above but for region-wise spatial extent
mask_map_regional_spex <- read_csv(glue("{project_space}/long_spex_gmm_mask.csv")) 
mask_map_regional_spex_long <- mask_map_regional_spex %>%
  left_join(ids_index, by=c("RID", "EXAMDATE_tau", "tau_pet_number")) %>%
  filter(AB_POSITIVITY_WCR == "AB+") %>%
  group_by(RID) %>%
  filter(tau_pet_number <= 3) %>%
  filter(n_distinct(tau_pet_number) >= 3) %>%
  ungroup() %>%
  select(-RID, -AB_POSITIVITY_WCR, -EXAMDATE_tau, -spatial_extent_thresh_0.5)


#Compute the size of each diagnostic group, to use as % of slope
mask_map_regional_spex_long %>% filter(tau_pet_number == 1) %>% filter(DIAGNOSIS == "CU") %>% summarize(n = n()) #48 CU
mask_map_regional_spex_long %>% filter(tau_pet_number == 1) %>% filter(DIAGNOSIS == "MCI") %>% summarize(n = n()) #33 MCI
mask_map_regional_spex_long %>% filter(tau_pet_number == 1) %>% filter(DIAGNOSIS == "AD") %>% summarize(n = n()) #19 AD
```

```{r}
#Same thing as above the SUVR, but with one distinction: the LME outputs the number of regions becoming positive per year for the subsample.
#This number might be biased because the sample sizes are different, so CU can have a max of 48 participants becoming positive on a region
# while AD can have a max of 19 participants becoming positive on a region. Instead, we find the percentage of the group that changes
spex_cu_long <- region_wise_slopes(mask_map_regional_spex_long, DIAG="CU", SIZE=48) #Here we give the sample size to calculate the percentage
spex_mci_long <- region_wise_slopes(mask_map_regional_spex_long, DIAG="MCI", SIZE=33)
spex_ad_long <- region_wise_slopes(mask_map_regional_spex_long, DIAG="AD", SIZE=19)

ggseg_spex_cu_long <- brain_template_plotting_long(spex_cu_long, limits_y=c(-1.06,7), legend_name="% annual spatial\nextent index change", plot_name="Cognitively\nUnimpaired A\U03B2+")
ggseg_spex_mci_long <- brain_template_plotting_long(spex_mci_long, limits_y=c(-1.06,7), legend_name="% annual spatial\nextent index change", plot_name="Mild Cognitive\nImpairment A\U03B2+")
ggseg_spex_ad_long <- brain_template_plotting_long(spex_ad_long, limits_y=c(-1.06,7), legend_name="% annual spatial\nextent index change", plot_name="Alzheimer's\ndisease A\U03B2+")

ggseg_spex_long <- wrap_elements((ggseg_spex_cu_long + ggseg_spex_mci_long + ggseg_spex_ad_long + plot_layout(guides = "collect") & theme(legend.position = 'bottom', plot.margin = unit(c(0,0,0,0), "cm"))) + plot_annotation(title='C', theme=thm))

#ggseg_spex_long <- ggseg_spex_cu_long + ggseg_spex_mci_long + ggseg_spex_ad_long + plot_layout(guides = "collect") & theme(legend.position = 'bottom')

#ggsave(glue("{figure_space}/figure4c_raw.png", plot=ggseg_spex_long), width = 15, height = 6, dpi=500)

```

```{r}
figure4 <- (patch_heatmap_ab_pos_long / ggseg_suvr_long / ggseg_spex_long) + plot_layout(heights = c(10, 6, 6), widths = c(15, 6, 6))


ggsave(glue("{figure_space}/figure4_raw.png"), plot=figure4, width = 11.2, height = 16, dpi=500)
```


```{r}
#Reviewer comment
max(spex_cu_long$regional_long_change_tau)
ggseg_spex_cu_long <- brain_template_plotting_long(spex_cu_long, limits_y=c(-1.06, 5.75), legend_name="% annual spatial\nextent index change", plot_name="Cognitively\nUnimpaired A\U03B2+")

ggsave(glue("{figure_space}/suppfigX10_raw.png", plot=ggseg_spex_cu_long), width = 5, height = 6, dpi=500) #save
```


### 6. Figure 5

Next is figure 5. In Figure 5, we compute the association between cognition and composite tau-PET measures. To maximize the space of the plots and avoid having like 10 tables, we output many stats on the plots directly.

In panel A, we want the cross-sectional cognition (at baseline)

```{r}
final_data_cog_ab_pos <- final_data %>%
    filter(AB_POSITIVITY_WCR == 1) %>%
    mutate(DIAGNOSIS = case_when(DIAGNOSIS == 1 ~ 'CU',
                                 DIAGNOSIS == 2 ~ 'MCI',
                                 DIAGNOSIS == 3 ~ 'AD'))

cog_meta_mem_bl <- biom_comp(final_data_cog_ab_pos, bio="meta_roi_tau_jack_tau", outcome="ADNI_MEM",
                        x_lab_val="Temporal meta-ROI SUVR", lim_x_vals = c(1.0, 3.4), y_lab_val = "Memory composite score", lim_y_vals = c(-3, 3),
                        lm_diagnostics = FALSE)
cog_spex_mem_bl <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_0.5", outcome="ADNI_MEM",
                        x_lab_val="Spatial Extent Index", lim_x_vals = c(0, 70), y_lab_val = "Memory composite score", lim_y_vals = c(-3, 3),
                        lm_diagnostics = FALSE)

thm <- theme(plot.title = element_text(face = 2, size = 16))
cog_mem_bl_patch <- wrap_elements((cog_meta_mem_bl / cog_spex_mem_bl) + plot_annotation(title='A', theme=thm))

#ggsave(glue("{figure_space}/figure5a_raw.png"), plot=cog_mem_bl_patch, width=12, height=6, dpi=500)
```

In panel B, we want the longitudinal cognition (overtime in ADNI) with baseline tau measures.

```{r}
final_data_cog_ab_pos <- final_data %>%
    filter(AB_POSITIVITY_WCR == 1) %>%
    mutate(DIAGNOSIS = case_when(DIAGNOSIS == 1 ~ 'CU',
                                 DIAGNOSIS == 2 ~ 'MCI',
                                 DIAGNOSIS == 3 ~ 'AD'))

cog_meta_mem_long <- biom_comp(final_data_cog_ab_pos, bio="meta_roi_tau_jack_tau", outcome="annual_slope_adnimem",
                        x_lab_val="Temporal meta-ROI SUVR", lim_x_vals = c(1.0, 3.4), y_lab_val = "Memory composite score decline", lim_y_vals = c(-0.43, 0.16),
                        lm_diagnostics = FALSE)
cog_spex_mem_long <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_0.5", outcome="annual_slope_adnimem",
                        x_lab_val="Spatial Extent Index", lim_x_vals = c(0, 70), y_lab_val = "Memory composite score decline", lim_y_vals =  c(-0.43, 0.16),
                        lm_diagnostics = FALSE)

thm <- theme(plot.title = element_text(face = 2, size = 16))
cog_mem_long_patch <- wrap_elements((cog_meta_mem_long / cog_spex_mem_long) + plot_annotation(title='B', theme=thm))

#cog_mem_long_patch <- (cog_meta_mem_long / cog_spex_mem_long)

#ggsave(glue("{figure_space}/figure5b_raw.png"), plot=cog_mem_long_patch, width=12, height=6, dpi=500)
```

```{r}
figure5 <- cog_mem_bl_patch / cog_mem_long_patch

ggsave(glue("{figure_space}/figure5_raw.png"), plot=figure5, width=12, height=12, dpi=500)
```


Comparing the model fit between the meta-ROI and the spatial extent index

```{r}
vuongtest(lm(ADNI_MEM ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")),
          lm(ADNI_MEM ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")))

vuongtest(lm(ADNI_MEM ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")),
          lm(ADNI_MEM ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")))

vuongtest(lm(ADNI_MEM ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")),
          lm(ADNI_MEM ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")))

vuongtest(lm(annual_slope_adnimem ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")),
          lm(annual_slope_adnimem ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")))

vuongtest(lm(annual_slope_adnimem ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")),
          lm(annual_slope_adnimem ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")))

vuongtest(lm(annual_slope_adnimem ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")),
          lm(annual_slope_adnimem ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")))
```


### 7. Figure 6 

In figure 6, we check if the association between tau SUVR in each brain region is associated with each cognitive measure.

```{r}
ids_index <- final_data %>%
    select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, PTAGE, PTGENDER, PTEDUCAT, ADNI_MEM, ADNI_EF, ADNI_LAN, ADNI_VSP,
           annual_slope_adnimem, annual_slope_adnief, annual_slope_adnilan, annual_slope_adnivsp) %>% #Only keep variables we need (variables to filter sample, covariates and outcome variables)
    #Transform the numbers to factors, which makes it easier to deal with when arranging them.
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(AB_POSITIVITY_WCR = as.factor(case_when(AB_POSITIVITY_WCR == 0 ~ "AB-",
                                         AB_POSITIVITY_WCR == 1 ~ "AB+")))
```


```{r}
mask_map_regional_suvr <- read_csv(glue("{project_space}/suvr_values_long.csv")) 
mask_map_regional_suvr_bl <- mask_map_regional_suvr %>%
    filter(tau_pet_number == 1) %>% #Keep only baselines
    select(-c(EXAMDATE_tau, tau_pet_number)) %>% #Remove examdate and tau_pet_number (no longer useful)
    left_join(ids_index) %>% 
    filter(AB_POSITIVITY_WCR == "AB+") %>%
    select(-RID, -AB_POSITIVITY_WCR) %>%
    relocate(DIAGNOSIS:annual_slope_adnivsp, .before = 'CTX_LH_BANKSSTS_SUVR') #Ships all demographics before regional values
```


```{r}
#Run the region-wise analyses for each cognitive measures (cross-sectional cognition and then longitudinal cogntion)
patch_cross_cu <- region_wise_regressions(data=mask_map_regional_suvr_bl, cog_vars = c("ADNI_MEM", "ADNI_EF", "ADNI_LAN", "ADNI_VSP"), DIAG="CU", fill_lims=c(-0.65, -0.15))
patch_cross_mci <- region_wise_regressions(data=mask_map_regional_suvr_bl, cog_vars = c("ADNI_MEM", "ADNI_EF", "ADNI_LAN", "ADNI_VSP"), DIAG="MCI", fill_lims=c(-0.65, -0.15))
patch_cross_ad <- region_wise_regressions(data=mask_map_regional_suvr_bl, cog_vars = c("ADNI_MEM", "ADNI_EF", "ADNI_LAN", "ADNI_VSP"), DIAG="AD", fill_lims=c(-0.65, -0.15))

patch_long_cu <- region_wise_regressions(data=mask_map_regional_suvr_bl, cog_vars = c("annual_slope_adnimem", "annual_slope_adnief", "annual_slope_adnilan", "annual_slope_adnivsp"), DIAG="CU", fill_lims=c(-0.75, -0.18))
patch_long_mci <- region_wise_regressions(data=mask_map_regional_suvr_bl, cog_vars =  c("annual_slope_adnimem", "annual_slope_adnief", "annual_slope_adnilan", "annual_slope_adnivsp"), DIAG="MCI", fill_lims=c(-0.75, -0.18))
patch_long_ad <- region_wise_regressions(data=mask_map_regional_suvr_bl, cog_vars =  c("annual_slope_adnimem", "annual_slope_adnief", "annual_slope_adnilan", "annual_slope_adnivsp"), DIAG="AD", fill_lims=c(-0.75, -0.18))

ggsave(glue("{figure_space}/figure6a_cu_raw.png"), plot=patch_cross_cu, width=24, height=8, dpi=500)
ggsave(glue("{figure_space}/figure6a_mci_raw.png"), plot=patch_cross_mci, width=24, height=8, dpi=500)
ggsave(glue("{figure_space}/figure6a_ad_raw.png"), plot=patch_cross_ad, width=24, height=8, dpi=500)

ggsave(glue("{figure_space}/figure6b_cu_raw.png"), plot=patch_long_cu, width=24, height=8, dpi=500)
ggsave(glue("{figure_space}/figure6b_mci_raw.png"), plot=patch_long_mci, width=24, height=8, dpi=500)
ggsave(glue("{figure_space}/figure6b_ad_raw.png"), plot=patch_long_ad, width=24, height=8, dpi=500)
```



### 8. Supp Figure 1

This figure is a copy of Figure 3A and 4A, but for the Amyloid negative participants

```{r}
#Finding the variables on the participants that should be included in the analysis
ids_index <- final_data %>%
    select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5) %>% #Only keep variables we need
    #Transform the numbers to factors, which makes it easier to deal with when arranging them.
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(AB_POSITIVITY_WCR = as.factor(case_when(AB_POSITIVITY_WCR == 0 ~ "AB-",
                                         AB_POSITIVITY_WCR == 1 ~ "AB+")))

#Import binary masks 
mask_regional_se_gmm <- read_csv(glue("{project_space}/long_spex_gmm_mask.csv")) 
mask_regional_se_gmm_bl<- mask_regional_se_gmm %>%
    filter(tau_pet_number == 1) %>% #Keep only baselines
    select(-c(EXAMDATE_tau, tau_pet_number)) %>% #Remove examdate and tau_pet_number (no longer useful)
    left_join(ids_index) %>% #Merge the DX, AB and tau status which we need to sort and classify
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("AD", "MCI", "CU"))) %>% #Relevel the factors in the order we want
    mutate(AB_POSITIVITY_WCR = fct_relevel(AB_POSITIVITY_WCR, c("AB-", "AB+"))) %>%
    group_by(DIAGNOSIS, AB_POSITIVITY_WCR) %>% #We group by diagnosis and AB positivity status
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, -spatial_extent_thresh_0.5) %>% #We arrange participants by diagnosis, positivity and spatial extent (this last one, from highest to lowest to the bars all go to the bottom of each section)
    #Pivot to a long format. This is needed for ggplot to understand that the regions are the x-axis of the heatmap
    pivot_longer(cols = -c(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), names_to="regions", values_to = "spex") %>%
    mutate(regions = as.factor(regions)) %>% #Make regions as factor
    mutate(regions = fct_relevel(regions, all_braak)) %>% #Make sure regions are in the Braak order
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, regions, -spatial_extent_thresh_0.5) %>% #Final sort, making sure the regions will show up in Braak order
    ungroup()

#Repeat the same process for the Braak stages
#Import binary masks
mask_braak_se_gmm <- read_csv(glue("{project_space}/long_spex_gmm_braak_mask.csv")) 
mask_braak_se_gmm_bl <- mask_braak_se_gmm %>%
    select(-meta_roi_tau_jack) %>%
    filter(tau_pet_number == 1) %>%
    select(-c(EXAMDATE_tau, tau_pet_number)) %>%
    left_join(ids_index) %>%
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("AD", "MCI", "CU"))) %>%
    mutate(AB_POSITIVITY_WCR = fct_relevel(AB_POSITIVITY_WCR, c("AB-", "AB+"))) %>%
    group_by(DIAGNOSIS, AB_POSITIVITY_WCR) %>%
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, -spatial_extent_thresh_0.5) %>%
    pivot_longer(cols = -c(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), names_to="regions", values_to = "spex") %>%
    mutate(regions = as.factor(regions)) %>%
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, regions, -spatial_extent_thresh_0.5) %>%
    ungroup()

```

```{r}
#Repeat the same process for AB negative (this will be supplementary figure 2, but easier to have here for now)
# heat_map_braak_ab_neg <- mask_braak_se_gmm_bl %>%
#   mutate(RID = fct_inorder(as.factor(RID))) %>%
#   #filter(spex_low >= 1) %>%
#   filter(AB_POSITIVITY_WCR == "AB-") %>%
#   ggplot(aes(y=RID, x=regions, fill=as.factor(spex))) +
#   geom_tile() +
#   theme_classic() +
#   scale_fill_manual(values = c("#024F6D", "#FDE725"), labels=c("Negative", "Positive"), name="Regional positivity\nstatus") +
#   annotate("segment", x=0.15, xend=0.15, y=1, yend=15, color="#ed1b2f") +
#   annotate("Text", x=-0.5, y=7, angle=90, label='AD A\U03B2-', color="#ed1b2f") +
#   annotate("segment", x=0.15, xend=0.15, y=16, yend=159, color="#F7941D") +
#   annotate("Text", x=-0.5, y=87.5, angle=90, label='MCI A\U03B2-', color="#F7941D") +
#   annotate("segment", x=0.15, xend=0.15, y=160, yend=460, color="#44C8F5") +
#   annotate("Text", x=-0.5, y=311, angle=90, label='CU A\U03B2-', color="#44C8F5") +
#   scale_x_discrete(labels=c("I", "III", "IV", "V", "VI")) +
#   ylab("Participants \n(by diagnosis)") +
#   xlab("Regions") +
#   coord_cartesian(clip="off") +
#   theme(axis.text.y = element_blank(),
#         axis.ticks.y = element_blank(),
#         line = element_blank(),
#         axis.title.y = element_text(vjust=2.5, face="bold", size=14),
#         text = element_text(family="sans"), #Imposes font family and size
#         axis.title.x = element_text(face="bold", size=14),
#         axis.text.x = element_text(size = 12),
#         legend.position = "none")
# 
# heat_map_ab_neg <- mask_regional_se_gmm_bl %>%
#   mutate(RID = fct_inorder(as.factor(RID))) %>%
#   filter(AB_POSITIVITY_WCR == "AB-") %>%
#   ggplot(aes(y=RID, x=regions, fill=as.factor(spex))) +
#   geom_tile() +
#   theme_classic() +
#   scale_fill_manual(values = c("#024F6D", "#FDE725"), labels=c("Negative", "Positive"), name="Regional positivity\nstatus") +
#   annotate("segment", x=0.15, xend=0.15, y=1, yend=15, color="#ed1b2f") +
#   annotate("Text", x=-0.5, y=7, angle=90, label='AD A\U03B2-', color="#ed1b2f") +
#   annotate("segment", x=0.15, xend=0.15, y=16, yend=159, color="#F7941D") +
#   annotate("Text", x=-0.5, y=87.5, angle=90, label='MCI A\U03B2-', color="#F7941D") +
#   annotate("segment", x=0.15, xend=0.15, y=160, yend=460, color="#44C8F5") +
#   annotate("Text", x=-0.5, y=311, angle=90, label='CU A\U03B2-', color="#44C8F5") +
#   geom_vline(xintercept = 2.5, color="black") +
#   geom_vline(xintercept = 10.5, color="black") +
#   geom_vline(xintercept = 26.5, color="black") +
#   geom_vline(xintercept = 58.5, color="black") +
#   geom_vline(xintercept = 42.5, color="black", linetype="dashed") +
#   annotate("text", x=1.5, y=-3, label="I", size=4) +
#   annotate("text", x=6, y=-3, label="III", size=4) +
#   annotate("text", x=18, y=-3, label="IV", size=4) +
#   annotate("text", x=34, y=-3, label="V - Parietal", size=4) +
#   annotate("text", x=50, y=-3, label="V - Frontal", size=4) +
#   annotate("text", x=64, y=-3, label="VI", size=4) +
#   coord_cartesian(clip="off") +
#   xlab("Regions") +
#   theme(axis.text.x = element_blank(),
#         axis.text.y = element_blank(),
#         axis.ticks.y = element_blank(),
#         axis.ticks.x = element_blank(),
#         line = element_blank(),
#         axis.title.y = element_blank(),
#         axis.title.x = element_text(vjust=-0.2, face="bold", size=14),
#         legend.text = element_text(size=12),
#         legend.title = element_text(size=14))

#patch_heatmap_ab_neg <- heat_map_braak_ab_neg + heat_map_ab_neg + plot_layout(widths = c(1.5, 12))

#ggsave(glue("{figure_space}/suppfigure1a_raw.png"), plot=patch_heatmap_ab_neg, width = 14.5, height = 8, units="in", dpi=500)
```

Repeat the entire process but longitudinally for Amyloid negative participants.

```{r}
#Finding the variables on the participants that should be included in the analysis
ids_index <- final_data %>%
    select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5) %>% #Only keep variables we need
    #Transform the numbers to factors, which makes it easier to deal with when arranging them.
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(AB_POSITIVITY_WCR = as.factor(case_when(AB_POSITIVITY_WCR == 0 ~ "AB-",
                                         AB_POSITIVITY_WCR == 1 ~ "AB+")))

#Import binary masks
mask_regional_se_gmm <- read_csv(glue("{project_space}/long_spex_gmm_mask.csv")) 
mask_regional_se_gmm_long <- mask_regional_se_gmm %>%
    group_by(RID) %>% #We want longitudinal, so we need to figure out longitudinal visits for each RID
    filter(n_distinct(tau_pet_number) >= 2) %>% #Keep only people with 2 or more visits
    filter(row_number() == 1 | row_number()==n()) %>% #For each participant, keep the first and last row
    select(-c(EXAMDATE_tau)) %>% #Removing useless column
    left_join(ids_index) %>% #Merge the diagnosis and amyloid positivity information
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("AD", "MCI", "CU"))) %>% #Relevel diagnoses so AD will be at the bottom and AD at the top of the heatmap
    mutate(AB_POSITIVITY_WCR = fct_relevel(AB_POSITIVITY_WCR, c("AB-", "AB+"))) %>% #Relevel AB positivity so AB+ are together
    #Next, we pivot to a long format
    pivot_longer(cols = -c(RID, DIAGNOSIS, tau_pet_number, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), names_to="regions", values_to = "posit") %>%
    mutate(first_last_tag = ifelse(tau_pet_number == 1, "First", "Last")) %>% #For each participant, we tag the first observation as "First" and the second as "Last"
    #Next, we need to flip back to a wide format, so for each region, of each individual, we have the score for the first and last visit in two columns
    pivot_wider(id_cols = c(RID, regions, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), values_from = c(posit), names_from = c(first_last_tag)) %>%
    #We substract the first and last visits to get the conversion status
    mutate(first_minus_last = First - Last) %>%
    #Next, we change the "first_minus_last" to a proper conversion variable
    mutate(conversion = case_when(first_minus_last == 1 ~ "Pos_to_neg", #1 - 0 = 1
                                  first_minus_last == -1 ~ "Neg_to_pos", #0 - 1 = -1
                                  first_minus_last == 0 & First == 0 ~ "Stab_neg", #0 - 0 = 0, so we need to precise that the first visit is negative
                                  first_minus_last == 0 & Last == 1 ~ "Stab_pos")) %>% #1 - 1 = 0, so we need to precise that the last visit is positive
    mutate(regions = as.factor(regions)) %>%
    mutate(regions = fct_relevel(regions, all_braak)) %>%
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, regions, -spatial_extent_thresh_0.5) %>%
    ungroup()

#Repeat the process for Braak stages
mask_braak_se_gmm <- read_csv(glue("{project_space}/long_spex_gmm_braak_mask.csv")) 
mask_braak_se_gmm_long <- mask_braak_se_gmm %>%
    group_by(RID) %>% #We want longitudinal, so we need to figure out longitudinal visits for each RID
    select(-c(meta_roi_tau_jack)) %>% #Remove the meta-ROI: we only want the Braak stages
    filter(n_distinct(tau_pet_number) >= 2) %>% #Keep only people with 2 or more visits
    filter(row_number() == 1 | row_number()==n()) %>% #For each participant, keep the first and last row
    select(-c(EXAMDATE_tau)) %>% #Removing useless column
    left_join(ids_index) %>% #Merge the diagnosis and amyloid positivity information
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("AD", "MCI", "CU"))) %>% #Relevel diagnoses so AD will be at the bottom and AD at the top of the heatmap
    mutate(AB_POSITIVITY_WCR = fct_relevel(AB_POSITIVITY_WCR, c("AB-", "AB+"))) %>% #Relevel AB positivity so AB+ are together
    #Next, we pivot to a long format
    pivot_longer(cols = -c(RID, DIAGNOSIS, tau_pet_number, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), names_to="regions", values_to = "posit") %>%
    mutate(first_last_tag = ifelse(tau_pet_number == 1, "First", "Last")) %>% #For each participant, we tag the first observation as "First" and the second as "Last"
    #Next, we need to flip back to a wide format, so for each region, of each individual, we have the score for the first and last visit in two columns
    pivot_wider(id_cols = c(RID, regions, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), values_from = c(posit), names_from = c(first_last_tag)) %>%
    #We substract the first and last visits to get the conversion status
    mutate(first_minus_last = First - Last) %>%
    #Next, we change the "first_minus_last" to a proper conversion variable
    mutate(conversion = case_when(first_minus_last == 1 ~ "Pos_to_neg", #1 - 0 = 1
                                  first_minus_last == -1 ~ "Neg_to_pos", #0 - 1 = -1
                                  first_minus_last == 0 & First == 0 ~ "Stab_neg", #0 - 0 = 0, so we need to precise that the first visit is negative
                                  first_minus_last == 0 & Last == 1 ~ "Stab_pos")) %>% #1 - 1 = 0, so we need to precise that the last visit is positive
    mutate(regions = as.factor(regions)) %>%
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, regions, -spatial_extent_thresh_0.5) %>%
    ungroup()
```

Now that these preparations are done, the data is ready to plot. We will plot for Braak stages and for regions, and then patch them together.

```{r}
#From here, the code is the same as Figure 3A, excepted for the "scale_fill_manual" function.
heat_map_ab_neg_braak_long <- mask_braak_se_gmm_long %>%
  mutate(RID = fct_inorder(as.factor(RID))) %>%
  filter(AB_POSITIVITY_WCR == "AB-") %>%
  ggplot(aes(y=RID, x=regions, fill=as.factor(conversion))) +
  geom_tile() +
  theme_classic() + 
  scale_fill_manual(values = c("red", "#44C8F5", "#024F6D", "yellow"), labels=c("Progressors", "Regressors", "Stable negative", "Stable positive"), name="Tau progression status") +
  annotate("segment", x=0.15, xend=0.15, y=1, yend=10, color="#ed1b2f") +
  annotate("Text", x=-0.5, y=5, angle=90, label='AD A\U03B2-', color="#ed1b2f") +
  annotate("segment", x=0.15, xend=0.15, y=11, yend=50, color="#F7941D") +
  annotate("Text", x=-0.5, y=30, angle=90, label='MCI A\U03B2-', color="#F7941D") +
  annotate("segment", x=0.15, xend=0.15, y=51, yend=146, color="#44C8F5") +
  annotate("Text", x=-0.5, y=98.5, angle=90, label='CU A\U03B2-', color="#44C8F5") +
  #geom_vline(xintercept = 1.5, linetype="dashed", color="black") +
  scale_x_discrete(labels=c("I", "III", "IV", "V", "VI")) +
  ylab("Participants \n(by diagnosis)") +
  xlab("Regions") +
  coord_cartesian(clip="off") +
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        line = element_blank(),
        axis.title.y = element_text(vjust=2.5, face="bold", size=14),
        text = element_text(family="sans"), #Imposes font family and size
        axis.title.x = element_text(face="bold", size=14),
        legend.position = "none")

#Code is the same as Figure 3A excepted for the "scale_fill_manual" function
heat_map_ab_neg_long <- mask_regional_se_gmm_long %>%
  mutate(RID = fct_inorder(as.factor(RID))) %>%
  filter(AB_POSITIVITY_WCR == "AB-") %>%
  ggplot(aes(y=RID, x=regions, fill=as.factor(conversion))) +
  geom_tile() +
  theme_classic() +
  scale_fill_manual(values = c("red", "#44C8F5", "#024F6D", "yellow"), 
                    labels=c("Progressors", "Regressors","Stable negative", "Stable positive"), 
                    name="Tau progression status") +
  annotate("segment", x=0.15, xend=0.15, y=1, yend=10, color="#ed1b2f") +
  annotate("Text", x=-0.5, y=5, angle=90, label='AD A\U03B2-', color="#ed1b2f") +
  annotate("segment", x=0.15, xend=0.15, y=11, yend=50, color="#F7941D") +
  annotate("Text", x=-0.5, y=30, angle=90, label='MCI A\U03B2-', color="#F7941D") +
  annotate("segment", x=0.15, xend=0.15, y=51, yend=146, color="#44C8F5") +
  annotate("Text", x=-0.5, y=98.5, angle=90, label='CU A\U03B2-', color="#44C8F5") +
  geom_vline(xintercept = 2.5, color="black") +
  geom_vline(xintercept = 10.5, color="black") +
  geom_vline(xintercept = 26.5, color="black") +
  geom_vline(xintercept = 58.5, color="black") +
  geom_vline(xintercept = 42.5, color="black", linetype="dashed") +
  annotate("text", x=1.5, y=-1.5, label="I", size=4) +
  annotate("text", x=6, y=-1.5, label="III", size=4) +
  annotate("text", x=18, y=-1.5, label="IV", size=4) +
  annotate("text", x=34, y=-1.5, label="V - Parietal", size=4) +
  annotate("text", x=50, y=-1.5, label="V - Frontal", size=4) +
  annotate("text", x=64, y=-1.5, label="VI", size=4) +
  coord_cartesian(clip="off") +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        line = element_blank(),
        axis.title.y = element_blank(),
        axis.title.x = element_text(vjust=-0.2, face="bold", size=14),
        legend.text = element_text(size=12),
        legend.title = element_text(size=14)) +
  xlab("Regions")

patch_heatmap_ab_neg_long <- heat_map_ab_neg_braak_long + heat_map_ab_neg_long + plot_layout(widths = c(1.5, 12)) #Fit the Braak and cortical graphs together in one plot

ggsave(glue("{figure_space}/suppfigure1b_raw.png"), plot=patch_heatmap_ab_neg_long, width = 14.5, height = 8, units="in", dpi=500)
```

### 9. Supp Figure 2

Supplementary Figure 2 is a simple box+jitter plot, divided by diagnostic status.


```{r}
#Isolate the data needed for subplot C
plot_meta_spex_data <- final_data %>%
    filter(AB_POSITIVITY_WCR == 1) %>%
    select(DIAGNOSIS, meta_roi_tau_jack_tau, spatial_extent_thresh_0.5)

plot_meta_spex_data_cu <- plot_meta_spex_data %>%
    filter(DIAGNOSIS == 1)

plot_meta_spex_data_mci <- plot_meta_spex_data %>%
    filter(DIAGNOSIS == 2)

plot_meta_spex_data_ad <- plot_meta_spex_data %>%
    filter(DIAGNOSIS == 3)


#Correlations (we'll just do regressions to match the plot)
summary(lm(spatial_extent_thresh_0.5 ~ meta_roi_tau_jack_tau, data=plot_meta_spex_data_cu))
summary(lm(spatial_extent_thresh_0.5 ~ meta_roi_tau_jack_tau, data=plot_meta_spex_data_mci))
summary(lm(spatial_extent_thresh_0.5 ~ meta_roi_tau_jack_tau, data=plot_meta_spex_data_ad))
```

Next, move to the plot

```{r}
#Arrange the data for the plot
plot_meta_spex_data <- final_data %>%
    filter(AB_POSITIVITY_WCR == 1) %>% #Keep only AB+
    select(DIAGNOSIS, meta_roi_tau_jack_tau, spatial_extent_thresh_0.5) %>% #Keep only these variables
    #Convert the numbers to labels for easier use
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("CU", "MCI", "AD")))
    
```

```{r}
#First, we isolate meta-ROI tau and spatial extent
supp_fig_2 <- final_data %>%
    select(DIAGNOSIS, AB_POSITIVITY_WCR, meta_roi_tau_jack_tau, spatial_extent_thresh_0.5) %>%
    #Pivot longer and create a variable for which tau measure we use so we can keep the right one when plotting
    pivot_longer(cols = c(meta_roi_tau_jack_tau, spatial_extent_thresh_0.5), names_to = "variable") %>%
    #Few data transformation for legibility
    mutate(AB_POSITIVITY_WCR = as.factor(case_when(AB_POSITIVITY_WCR == 0 ~ "AB-",
                                         AB_POSITIVITY_WCR == 1 ~ "AB+"))) %>%
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                                 DIAGNOSIS == 2 ~ "MCI",
                                 DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("CU", "MCI", "AD")))

#Arrange the data for the plot (panel C)
plot_meta_spex_data <- final_data %>%
    filter(AB_POSITIVITY_WCR == 1) %>% #Keep only AB+
    select(DIAGNOSIS, meta_roi_tau_jack_tau, spatial_extent_thresh_0.5) %>% #Keep only these variables
    #Convert the numbers to labels for easier use
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("CU", "MCI", "AD")))

plot_meta_group <- supp_fig_2 %>%
    filter(variable == "meta_roi_tau_jack_tau") %>%
    ggplot(aes(x=AB_POSITIVITY_WCR, y=value, color=DIAGNOSIS, shape=AB_POSITIVITY_WCR)) +
    geom_boxplot(outlier.shape=NA, alpha=0.1) + #Remove outlier since we also do a geom_point
    geom_point(position = position_jitterdodge()) + #Use a jitter so it looks nicer
    #Color and shape the points to make it easier to read
    scale_color_manual(labels = c("CU", "MCI", "AD"), values = c("#44C8F5", "#F7941D", "#ED1B2F"), name = "Diagnostic status") +
    scale_shape_manual(values = c(25,16), name="A\U03B2 Positivity status") +
    scale_x_discrete(labels = c("A\U03B2-", "A\U03B2+"), name = "A\U03B2 Positivity status") +
    ylab("SUVR") +
    theme_classic() +
    theme(
    panel.grid.major = element_line(), #Reimports the axis grid (1/2)
        panel.grid.minor = element_line(), #Reimports the axis gris (1/2)
        text = element_text(family="sans"), #Imposes font family and size
        axis.title.x = element_text(face="bold"), #Bolds the axis title
        axis.title.y = element_text(face="bold"),
        plot.title = element_text(face="bold", size=16, hjust=0.5)
  )

#plot_meta_group

#Same as above, but using spatial extent
plot_spex_group <- supp_fig_2 %>%
    filter(variable == "spatial_extent_thresh_0.5") %>%
    ggplot(aes(x=AB_POSITIVITY_WCR, y=value, color=DIAGNOSIS, shape=AB_POSITIVITY_WCR)) +
    geom_boxplot(outlier.shape=NA, alpha=0.1) +
    geom_point(position = position_jitterdodge()) +
    scale_color_manual(labels = c("CU", "MCI", "AD"), values = c("#44C8F5", "#F7941D", "#ED1B2F"), name = "Diagnostic status") +
    scale_shape_manual(values = c(25,16), name="A\U03B2 Positivity status") +
    scale_x_discrete(labels = c("A\U03B2-", "A\U03B2+"), name = "A\U03B2 Positivity status") +
    ylab("Spatial extent index") +
    theme_classic() +
    theme(
    panel.grid.major = element_line(), #Reimports the axis grid (1/2)
        panel.grid.minor = element_line(), #Reimports the axis gris (1/2)
        text = element_text(family="sans"), #Imposes font family and size
        axis.title.x = element_text(face="bold"), #Bolds the axis title
        axis.title.y = element_text(face="bold"),
        plot.title = element_text(face="bold", size=16, hjust=0.5)
  )

#plot_spex_group

#Create the plot
plot_meta_spex <- plot_meta_spex_data %>%
    #We fill and color with diagnosis so we can use the alpha on the points
    ggplot(aes(x = meta_roi_tau_jack_tau, y = spatial_extent_thresh_0.5, fill=as.factor(DIAGNOSIS), color=as.factor(DIAGNOSIS))) +
    stat_smooth(formula = "y ~ x", method='lm', fullrange = TRUE) + #Use the fullrange so the lines are equal for all
    geom_point(alpha=0.5) + #Just for looking nice
    scale_color_manual(values = c("#44C8F5", "#F7941D", "#ED1B2F"), labels=c("CU", "MCI", "AD"), name='Diagnosis') +
    scale_fill_manual(values = c("#44C8F5", "#F7941D", "#ED1B2F"), labels=c("CU", "MCI", "AD"), name='Diagnosis') +
    theme_classic() +
    xlab("Temporal meta-ROI SUVR") +
    ylim(c(0,70)) + #Force limits to the expected spatial extent
    ylab("Spatial extent index (n/70)") +
    annotate("text", x=Inf, y=-Inf, hjust=1, vjust=-0.5, label=
    'CU \U03B2 = 36.89*** R\U00B2 adj = 0.46
     MCI \U03B2 = 48.52*** R\U00B2 adj = 0.80
     AD \U03B2 = 47.07*** R\U00B2 adj = 0.68\n') +
    theme(panel.grid.major = element_line(), #Reimports the axis grid (1/2)
          panel.grid.minor = element_line(), #Reimports the axis gris (1/2)
          #text = element_text(size=10, family="sans"), #Imposes font family and size
          text = element_text(family="sans"), #Imposes font family and size
          axis.title.x = element_text(face="bold"), #Bolds the axis title
          axis.title.y = element_text(face="bold")) 

#Group in a patchwork, and annotate the plots with tags. We also make the tag bigger
patch_supp_fig_2 <- ((plot_meta_group + plot_spex_group + plot_layout(guides = "collect")) / plot_meta_spex) + plot_annotation(tag_levels = 'A') &
    theme(plot.tag = element_text(face = 'bold', size=18))

ggsave(glue("{figure_space}/suppfigure2_raw.png"), plot=patch_supp_fig_2, width = 9, height=9, units="in", dpi=500)

```

Next, we run the statistics for this plot.

```{r}
#Below we run the stats comparing amyloid negative to amyloid positive for the variables.
meta_roi_data <- supp_fig_2 %>%
    filter(variable == "meta_roi_tau_jack_tau")

spex_data <- supp_fig_2 %>%
    filter(variable == "spatial_extent_thresh_0.5")

#To compare tau between AB positivity and diagnosis groups, we can do an ANOVA with AB_POSITIVITY interacting with the diagnostic group
summary(aov(value ~ AB_POSITIVITY_WCR * DIAGNOSIS, data = meta_roi_data))
TukeyHSD(aov(value ~ AB_POSITIVITY_WCR * DIAGNOSIS, data = meta_roi_data))
#We are interested in 3 comparisons: AB+:CU-AB-:CU, AB+:MCI-AB-:MCI, AB+:AD-AB-:AD
#They are all way below 0.005

summary(aov(value ~ AB_POSITIVITY_WCR * DIAGNOSIS, data = spex_data))
TukeyHSD(aov(value ~ AB_POSITIVITY_WCR * DIAGNOSIS, data = spex_data))
#We are interested in 3 comparisons: AB+:CU-AB-:CU, AB+:MCI-AB-:MCI, AB+:AD-AB-:AD
#The CU AB-, CU AB+ is not signif diff for spex. Change in manuscript.
```

### 10. Supp Figure 3

Supplementary figure 3, and the related statistics, aim to measure change over time in tau measures. We plot the rates on a graph, and control the rate for gender, age and education.

NOTE: THIS VERSION FOR THE SPATIAL EXTENT IS NO LONGER GOOD. THE MODEL CHANGED FOR THE SPATIAL EXTENT INDEX. PLEASE REFER TO R2: C.10 FOR THE RIGHT CODE.

```{r}
#Create the dataframe used for the final LMER models for meta_roi
meta_roi_long <- meta_roi_time_calc %>%
  select(RID, tau_pet_number, meta_roi_tau_jack_tau, cum_meta_roi_years) %>%
  left_join(final_data %>% select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, PTAGE, PTGENDER, PTEDUCAT),
            by=c('RID')) %>%
  filter(AB_POSITIVITY_WCR == 1) %>%
  filter(tau_pet_number <= 3) %>%
  mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
  mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("CU", "MCI", "AD"))) #%>%
  #mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("MCI", "CU", "AD"))) #To compare a different order in the group LME, if needed

#Create the dataframes used for the final LMER models for the spatial extent
spex_long <- spex_gmm_time_calc %>%
  select(RID, tau_pet_number, spatial_extent_thresh_0.5, cum_spex_gmm_years) %>%
  left_join(final_data %>% select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, PTAGE, PTGENDER, PTEDUCAT),
            by=c('RID')) %>%
  filter(AB_POSITIVITY_WCR == 1) %>%
  filter(tau_pet_number <= 3) %>%
  mutate(PTGENDER = as.factor(case_when(PTGENDER == 1 ~ "Male",
                              PTGENDER == 2 ~ "Female"))) %>%
  mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
  mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("CU", "MCI", "AD"))) #%>%
  #mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("MCI", "CU", "AD"))) #To compare a different order in the group LME, if needed

#run the model for each measure of tau, for each 
lmer_meta_cu <- lmer_tau(meta_roi_long, diag="CU", outcome = "meta_roi_tau_jack_tau", time = "cum_meta_roi_years", covar="PTGENDER + PTAGE + PTEDUCAT")
lmer_meta_mci <- lmer_tau(meta_roi_long, diag="MCI", outcome = "meta_roi_tau_jack_tau", time = "cum_meta_roi_years", covar="PTGENDER + PTAGE + PTEDUCAT")
lmer_meta_ad <- lmer_tau(meta_roi_long, diag="AD", outcome = "meta_roi_tau_jack_tau", time = "cum_meta_roi_years", covar="PTGENDER + PTAGE + PTEDUCAT")

lmer_spex_cu <- lmer_tau(data=spex_long, diag="CU", outcome="spatial_extent_thresh_0.5", time="cum_spex_gmm_years", covar="PTGENDER + PTAGE + PTEDUCAT")
lmer_spex_mci <- lmer_tau(data=spex_long, diag="MCI", outcome="spatial_extent_thresh_0.5", time="cum_spex_gmm_years", covar="PTGENDER + PTAGE + PTEDUCAT")
lmer_spex_ad <- lmer_tau(data=spex_long, diag="AD", outcome="spatial_extent_thresh_0.5", time="cum_spex_gmm_years", covar="PTGENDER + PTAGE + PTEDUCAT")

```

Additionally, we want to check if the rates of change differ between groups.

```{r}
#First, we assume the CU are the control group to compare against
lmer_meta_roi_group_diff <- lmer(meta_roi_tau_jack_tau ~ cum_meta_roi_years*DIAGNOSIS + PTGENDER + PTAGE + PTEDUCAT + (cum_meta_roi_years|RID), data=meta_roi_long)
summary(lmer_meta_roi_group_diff) #Only significant difference is between MCI and CU

lmer_spex_group_diff <- lmer(spatial_extent_thresh_0.5 ~ cum_spex_gmm_years*DIAGNOSIS + PTGENDER + PTAGE + PTEDUCAT + (cum_spex_gmm_years|RID), data=spex_long)
summary(lmer_spex_group_diff) #Only significant difference is between MCI and AD

#Next, we invert the factors, with MCI being the control group, to check differences between all groups
invert_factors_meta_roi_long <- meta_roi_long %>%
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("MCI", "CU", "AD")))

invert_factors_spex_long <- spex_long %>%
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("MCI", "CU", "AD")))

invert_lmer_meta_roi_group_diff <- lmer(meta_roi_tau_jack_tau ~ cum_meta_roi_years*DIAGNOSIS + PTGENDER + PTAGE + PTEDUCAT + (cum_meta_roi_years|RID), data=invert_factors_meta_roi_long)
summary(invert_lmer_meta_roi_group_diff) #Only significant difference is between MCI and CU

invert_lmer_spex_group_diff <- lmer(spatial_extent_thresh_0.5 ~ cum_spex_gmm_years*DIAGNOSIS + PTGENDER + PTAGE + PTEDUCAT + (cum_spex_gmm_years|RID), data=invert_factors_spex_long)
summary(invert_lmer_spex_group_diff) #Significant differences with both CU and AD
```

Now we can get on with the plots

```{r}
ggplot_meta_roi_jack_long <- meta_roi_long %>%
  ggplot(aes(x=cum_meta_roi_years, y=meta_roi_tau_jack_tau)) +
  geom_point(aes(color=as.factor(DIAGNOSIS)), alpha=0.7) +
  geom_line(aes(group=RID, color=as.factor(DIAGNOSIS)), alpha=0.1) +
  annotate("segment", x=min(meta_roi_long$cum_meta_roi_years), #The start of the segment is the minimum years in the data (so 0)
           xend=max(meta_roi_long$cum_meta_roi_years), #The end is the maximum years in the data 
           #Next, we draw the segment. The y is the start (i.e, intercept).
           #The end of the y is equal to the intercept (when slope is 0) + the slope (tau per year) multiplied by the maximum number of years
           y=lmer_meta_cu[[1,2]], yend=lmer_meta_cu[[1,2]] + lmer_meta_cu[[1,3]]*max(meta_roi_long$cum_meta_roi_years), 
           size=0.50, color="#44C8F5") +
            #The ribbon is a representation of the error in representing the slope. It's not particularly visible in most cases, so we multiply
            #the error by 3 to make it visible.
            #Geom ribbon only takes one X, which should be the time of each participant.
            #Then, for the y, we make it follow the slope, so we need to copy the same code, but with the twist that we multiply the slope by
            #the error
  geom_ribbon(aes(x=cum_meta_roi_years, 
                  ymin=cum_meta_roi_years*lmer_meta_cu[[1,3]] + lmer_meta_cu[[1,2]] - (lmer_meta_cu[[1,4]]*3),
                  ymax=cum_meta_roi_years*lmer_meta_cu[[1,3]] + lmer_meta_cu[[1,2]] + (lmer_meta_cu[[1,4]]*3)), 
              fill="#44C8F5", alpha=0.3) +
  
  annotate("segment", x=min(meta_roi_long$cum_meta_roi_years), #This segment is the slope of MCI
           xend=max(meta_roi_long$cum_meta_roi_years),
           y=lmer_meta_mci[[1,2]], yend=lmer_meta_mci[[1,2]] + lmer_meta_mci[[1,3]]*max(meta_roi_long$cum_meta_roi_years), 
           size=0.50, color="#F7941D") +
  geom_ribbon(aes(x=cum_meta_roi_years, 
                  ymin=cum_meta_roi_years*lmer_meta_mci[[1,3]] + lmer_meta_mci[[1,2]] - (lmer_meta_mci[[1,4]]*3),
                  ymax=cum_meta_roi_years*lmer_meta_mci[[1,3]] + lmer_meta_mci[[1,2]] + (lmer_meta_mci[[1,4]]*3)), 
              fill="#F7941D", alpha=0.3) +
  
  annotate("segment", x=min(meta_roi_long$cum_meta_roi_years), #This segment is the slope of AD
           xend=max(meta_roi_long$cum_meta_roi_years),
           y=lmer_meta_ad[1,2][[1]], yend=lmer_meta_ad[[1,2]] + lmer_meta_ad[[1,3]]*max(meta_roi_long$cum_meta_roi_years),
           size=0.50, color="#ED1B2F") +
  geom_ribbon(aes(x=cum_meta_roi_years, 
                  ymin=cum_meta_roi_years*lmer_meta_ad[[1,3]] + lmer_meta_ad[[1,2]] - (lmer_meta_ad[[1,4]]*3),
                  ymax=cum_meta_roi_years*lmer_meta_ad[[1,3]] + lmer_meta_ad[[1,2]] + (lmer_meta_ad[[1,4]]*3)),
              fill="#ED1B2F", alpha=0.3) +
  
  annotate("text", y=Inf, x =Inf, hjust=1, vjust=1.3,  
           label=glue("\U03B2 CU = {round(lmer_meta_cu[1,3][[1]], 3)} SUVR/year ***
                      \U03B2 MCI = {round(lmer_meta_mci[1,3][[1]], 3)} SUVR/year ***
                      \U03B2 AD = {round(lmer_meta_ad[1,3][[1]], 3)} SUVR/year   ")) +
#\n\U03B2std CU = 0.132\n\U03B2std MCI = 0.144\n\U03B2std AD = 0.075
  scale_color_manual(values = c("#44C8F5", "#F7941D", "#ED1B2F"), labels=c("CU", "MCI", "AD"), name="Diagnostic\nstatus") +
  xlab("Time since baseline tau scan (years)") +
  ylab("Temporal meta-ROI SUVR") +
  theme_classic() +
  theme(panel.grid.major = element_line(), #Reimports the axis grid (1/2)
          panel.grid.minor = element_line(), #Reimports the axis gris (1/2)
          text = element_text(size=14, family="sans"), #Imposes font family and size
          axis.title.x = element_text(face="bold"), #Bolds the axis title
          axis.title.y = element_text(face="bold"),
          plot.title = element_text(face='bold', hjust=0.5))

#ggplot_meta_roi_jack_long
#Same plot for spatial extent
ggplot_spex_long <- spex_long %>%
  ggplot(aes(x=cum_spex_gmm_years, y=spatial_extent_thresh_0.5)) +
  geom_point(aes(color=as.factor(DIAGNOSIS)), alpha=0.7) +
  geom_line(aes(group=RID, color=as.factor(DIAGNOSIS)), alpha=0.1) +
  annotate("segment", x=min(spex_long$cum_spex_gmm_years), #The start of the segment is the minimum years in the data (so 0)
           xend=max(spex_long$cum_spex_gmm_years), #The end is the maximum years in the data 
           #Next, we draw the segment. The y is the start (i.e, intercept).
           #The end of the y is equal to the intercept (when slope is 0) + the slope (tau per year) multiplied by the maximum number of years
           y=lmer_spex_cu[[1,2]], yend=lmer_spex_cu[[1,2]] + lmer_spex_cu[[1,3]]*max(spex_long$cum_spex_gmm_years), 
           size=0.50, color="#44C8F5") +
            #The ribbon is a representation of the error in representing the slope. It's not particularly visible in most cases, so we multiply
            #the error by 3 to make it visible.
            #Geom ribbon only takes one X, which should be the time of each participant.
            #Then, for the y, we make it follow the slope, so we need to copy the same code, but with the twist that we multiply the slope by
            #the error
  geom_ribbon(aes(x=cum_spex_gmm_years, 
                  ymin=cum_spex_gmm_years*lmer_spex_cu[[1,3]] + lmer_spex_cu[[1,2]] - (lmer_spex_cu[[1,4]]*3),
                  ymax=cum_spex_gmm_years*lmer_spex_cu[[1,3]] + lmer_spex_cu[[1,2]] + (lmer_spex_cu[[1,4]]*3)), 
              fill="#44C8F5", alpha=0.3) +
  
  annotate("segment", x=min(spex_long$cum_spex_gmm_years), #This segment is the slope of MCI
           xend=max(spex_long$cum_spex_gmm_years),
           y=lmer_spex_mci[[1,2]], yend=lmer_spex_mci[[1,2]] + lmer_spex_mci[[1,3]]*max(spex_long$cum_spex_gmm_years), 
           size=0.50, color="#F7941D") +
  geom_ribbon(aes(x=cum_spex_gmm_years, 
                  ymin=cum_spex_gmm_years*lmer_spex_mci[[1,3]] + lmer_spex_mci[[1,2]] - (lmer_spex_mci[[1,4]]*3),
                  ymax=cum_spex_gmm_years*lmer_spex_mci[[1,3]] + lmer_spex_mci[[1,2]] + (lmer_spex_mci[[1,4]]*3)), 
              fill="#F7941D", alpha=0.3) +
  
  annotate("segment", x=min(spex_long$cum_spex_gmm_years), #This segment is the slope of AD
           xend=max(spex_long$cum_spex_gmm_years),
           y=lmer_spex_ad[1,2][[1]], yend=lmer_spex_ad[[1,2]] + lmer_spex_ad[[1,3]]*max(spex_long$cum_spex_gmm_years),
           size=0.50, color="#ED1B2F") +
  geom_ribbon(aes(x=cum_spex_gmm_years, 
                  ymin=cum_spex_gmm_years*lmer_spex_ad[[1,3]] + lmer_spex_ad[[1,2]] - (lmer_spex_ad[[1,4]]*3),
                  ymax=cum_spex_gmm_years*lmer_spex_ad[[1,3]] + lmer_spex_ad[[1,2]] + (lmer_spex_ad[[1,4]]*3)),
              fill="#ED1B2F", alpha=0.3) +
  
  annotate("text", y=Inf, x =Inf, hjust=1, vjust=1.3,  
           label=glue("\U03B2 CU = {round(lmer_spex_cu[1,3][[1]], 3)} regions/year ***
                      \U03B2 MCI = {round(lmer_spex_mci[1,3][[1]], 3)} regions/year ***
                      \U03B2 AD = {round(lmer_spex_ad[1,3][[1]], 3)} regions/year   ")) +
#\n\U03B2std CU = 0.132\n\U03B2std MCI = 0.144\n\U03B2std AD = 0.075
  scale_color_manual(values = c("#44C8F5", "#F7941D", "#ED1B2F"), labels=c("CU", "MCI", "AD"), name="Diagnostic\nstatus") +
  xlab("Time since baseline tau scan (years)") +
  ylab("Spatial extent index") +
  theme_classic() +
  theme(panel.grid.major = element_line(), #Reimports the axis grid (1/2)
          panel.grid.minor = element_line(), #Reimports the axis gris (1/2)
          text = element_text(size=14, family="sans"), #Imposes font family and size
          axis.title.x = element_text(face="bold"), #Bolds the axis title
          axis.title.y = element_text(face="bold"),
          plot.title = element_text(face="bold", hjust=0.5))

#ggplot_spex_long

```

```{r}
#Patch and tag the plots, and output

patch_lme_tau <- ggplot_meta_roi_jack_long + ggplot_spex_long + plot_annotation(tag_levels = 'A') &
    theme(plot.tag = element_text(face = 'bold', size=18))

ggsave(glue("{figure_space}/suppfigure3_raw.png"), plot=patch_lme_tau, width = 11.1, height=5, units="in", dpi=500)
```



### 11. Supp Figure 4

In this figure, we compare the patterns of tau positivity between individuals using the Jaccard index. The mask to calculate the Jaccard Index should be the same as we used for Figure 3 and 4

```{r}
#Finding the variables on the participants that should be included in the analysis
ids_index <- final_data %>%
    select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5) %>% #Only keep variables we need
    #Transform the numbers to factors, which makes it easier to deal with when arranging them.
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(AB_POSITIVITY_WCR = as.factor(case_when(AB_POSITIVITY_WCR == 0 ~ "AB-",
                                         AB_POSITIVITY_WCR == 1 ~ "AB+")))

#Import binary masks 
mask_regional_se_gmm <- read_csv(glue("{project_space}/long_spex_gmm_mask.csv")) 
mask_regional_se_gmm_bl<- mask_regional_se_gmm %>%
    filter(tau_pet_number == 1) %>% #Keep only baselines
    select(-c(EXAMDATE_tau, tau_pet_number)) %>% #Remove examdate and tau_pet_number (no longer useful)
    left_join(ids_index) %>% #Merge the DX, AB and tau status which we need to sort and classify
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("AD", "MCI", "CU"))) %>% #Relevel the factors in the order we want
    mutate(AB_POSITIVITY_WCR = fct_relevel(AB_POSITIVITY_WCR, c("AB-", "AB+"))) %>%
    group_by(DIAGNOSIS, AB_POSITIVITY_WCR) %>% #We group by diagnosis and AB positivity status
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, -spatial_extent_thresh_0.5) %>% #We arrange participants by diagnosis, positivity and spatial extent (this last one, from highest to lowest to the bars all go to the bottom of each section)
    #Pivot to a long format. This is needed for ggplot to understand that the regions are the x-axis of the heatmap
    pivot_longer(cols = -c(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), names_to="regions", values_to = "spex") %>%
    mutate(regions = as.factor(regions)) %>% #Make regions as factor
    mutate(regions = fct_relevel(regions, all_braak)) %>% #Make sure regions are in the Braak order
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, regions, -spatial_extent_thresh_0.5) %>% #Final sort, making sure the regions will show up in Braak order
    ungroup() %>%
    pivot_wider(id_cols = c(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), names_from = regions, values_from = spex)
```

Next, we calculate the average Jaccard index.

```{r}
#Create empty tibble to store Jaccard index the results
jacc_by_region_sum <- tribble( #This is the summarized results (mean and average) for each dx group
    ~diagnosis, ~avg_jacc, ~braak_stage, ~sd_jacc
)

jacc_by_region_ind <- tribble( #This is the average Jaccard coefficient by participant
    ~RID, ~diagnosis, ~braak_stage, ~avg_jac_ind
)

tags_braak <- list("all_braak"=all_braak, "braak_3"=braak_3_regs, "braak_4"=braak_4_regs, "braak_5_front"=braak_5_front_regs, "braak_5_rest"=braak_5_rest_regs, "braak_6"=braak_6_regs) #We skip Braak 1 because only 2 regions

#Run a nested loop for each diagnostic group, for each Braak stage
for (diag in c("CU", "MCI", "AD")) {
    
    for (braaks in seq_along(tags_braak)) {
         #Get the binary data in each brain region
        pre_jacc <- mask_regional_se_gmm_bl %>%
            filter(AB_POSITIVITY_WCR == "AB+") %>% #remove AB-
            filter(spatial_extent_thresh_0.5 >= 1) %>% #Keep people with at least one of SPEX
            filter(DIAGNOSIS == diag) %>% #Force to keep one diagnostic at a time
            select(-DIAGNOSIS, -AB_POSITIVITY_WCR, -spatial_extent_thresh_0.5, -RID) %>%
            select(tags_braak[[braaks]]) %>% #Select only regions in that Braak stage
            filter(rowSums(.) != 0) #We force the result to have at least one of the regions within the Braak stage to be positive
        
        #Get the ids so we know the value of each person
        pre_jacc_ids <- mask_regional_se_gmm_bl %>%
            filter(AB_POSITIVITY_WCR == "AB+") %>%
            filter(spatial_extent_thresh_0.5 >= 1) %>%
            filter(DIAGNOSIS == diag) %>%
            filter(rowSums(select(., tags_braak[[braaks]])) != 0) %>% #Force a least one of the regions within braak to be positive
            select(RID)
        
        #Compute the jaccard coefficient for each person
        jacc_dist <- jacc_alike_coef(pre_jacc, pre_jacc_ids)
        
        #Compute average and SD across each DX group for each Braak
        mean_jacc <- mean(jacc_dist$avg_jack_coef, na.rm = TRUE)
        sd_jacc <- sd(jacc_dist$avg_jack_coef, na.rm = TRUE)
        
        #Export summary values
        jacc_by_region_sum <- jacc_by_region_sum %>%
            add_row(diagnosis = diag, braak_stage = names(tags_braak)[braaks], avg_jacc = mean_jacc, sd_jacc = sd_jacc)
        
        jacc_by_region_ind <- jacc_by_region_ind %>%
            add_row(RID = jacc_dist$RID, diagnosis = diag, braak_stage = names(tags_braak)[braaks], avg_jac_ind = jacc_dist$avg_jack_coef)
    }
}


```

Next, we reproduce these steps but for the longitudinal data. First, clean the data:

```{r}
#Finding the variables on the participants that should be included in the analysis
ids_index <- final_data %>%
    select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5) %>% #Only keep variables we need
    #Transform the numbers to factors, which makes it easier to deal with when arranging them.
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(AB_POSITIVITY_WCR = as.factor(case_when(AB_POSITIVITY_WCR == 0 ~ "AB-",
                                         AB_POSITIVITY_WCR == 1 ~ "AB+")))

#Import binary masks
mask_regional_se_gmm <- read_csv(glue("{project_space}/long_spex_gmm_mask.csv")) 
mask_regional_se_gmm_long <- mask_regional_se_gmm %>%
    group_by(RID) %>% #We want longitudinal, so we need to figure out longitudinal visits for each RID
    filter(n_distinct(tau_pet_number) >= 2) %>% #Keep only people with 2 or more visits
    filter(row_number() == 1 | row_number()==n()) %>% #For each participant, keep the first and last row
    select(-c(EXAMDATE_tau)) %>% #Removing useless column
    left_join(ids_index) %>% #Merge the diagnosis and amyloid positivity information
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("AD", "MCI", "CU"))) %>% #Relevel diagnoses so AD will be at the bottom and AD at the top of the heatmap
    mutate(AB_POSITIVITY_WCR = fct_relevel(AB_POSITIVITY_WCR, c("AB-", "AB+"))) %>% #Relevel AB positivity so AB+ are together
    #Next, we pivot to a long format
    pivot_longer(cols = -c(RID, DIAGNOSIS, tau_pet_number, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), names_to="regions", values_to = "posit") %>%
    mutate(first_last_tag = ifelse(tau_pet_number == 1, "First", "Last")) %>% #For each participant, we tag the first observation as "First" and the second as "Last"
    #Next, we need to flip back to a wide format, so for each region, of each individual, we have the score for the first and last visit in two columns
    pivot_wider(id_cols = c(RID, regions, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), values_from = c(posit), names_from = c(first_last_tag)) %>%
    #We substract the first and last visits to get the conversion status
    mutate(first_minus_last = First - Last) %>%
    #Next, we change the "first_minus_last" to a proper conversion variable
    mutate(conversion = case_when(first_minus_last == 1 ~ "Pos_to_neg", #1 - 0 = 1
                                  first_minus_last == -1 ~ "Neg_to_pos", #0 - 1 = -1
                                  first_minus_last == 0 & First == 0 ~ "Stab_neg", #0 - 0 = 0, so we need to precise that the first visit is negative
                                  first_minus_last == 0 & Last == 1 ~ "Stab_pos")) %>% #1 - 1 = 0, so we need to precise that the last visit is positive
    mutate(regions = as.factor(regions)) %>%
    mutate(regions = fct_relevel(regions, all_braak)) %>%
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, regions, -spatial_extent_thresh_0.5) %>%
    ungroup()
```


```{r}
#Create empty tibble to store the results
jacc_by_region_sum_long <- tribble(
    ~diagnosis, ~avg_jacc, ~braak_stage, ~sd_jacc
)

jacc_by_region_ind_long <- tribble(
    ~RID, ~diagnosis, ~braak_stage, ~avg_jac_ind
)

for (diag in c("CU", "MCI", "AD")) {
    for (braaks in seq_along(tags_braak)) {

        #Get the binary data in each brain region
        pre_jacc <- mask_regional_se_gmm_long %>%
            filter(AB_POSITIVITY_WCR == "AB+") %>% #remove AB-
            filter(spatial_extent_thresh_0.5 >= 1) %>% #Keep people with at least one of SPEX
            filter(DIAGNOSIS == diag) %>%
            select(-DIAGNOSIS, -AB_POSITIVITY_WCR, -spatial_extent_thresh_0.5) %>%
            mutate(conversion = dplyr::recode(conversion, "Stab_neg" = 0, 'Neg_to_pos' = 1, 'Stab_pos' = 2, 'Pos_to_neg'= 3)) %>%
            pivot_wider(id_cols = "RID", names_from = "regions", values_from = "conversion") %>%
            select(tags_braak[[braaks]]) %>%
            filter(rowSums(.) != 0) #We force the result to have at least one of the regions within the Braak stage to be positive

        #Get the ids so we know the value of each person
        pre_jacc_ids <- mask_regional_se_gmm_long %>%
            filter(AB_POSITIVITY_WCR == "AB+") %>%
            filter(spatial_extent_thresh_0.5 >= 1) %>%
            filter(DIAGNOSIS == diag) %>%
            select(-DIAGNOSIS, -AB_POSITIVITY_WCR, -spatial_extent_thresh_0.5) %>%
            mutate(conversion = dplyr::recode(conversion, "Stab_neg" = 0, 'Neg_to_pos' = 1, 'Stab_pos' = 2, 'Pos_to_neg'= 3)) %>%
            pivot_wider(id_cols = "RID", names_from = "regions", values_from = "conversion") %>%
            filter(rowSums(select(., tags_braak[[braaks]])) != 0) %>% #Force a least one of the regions within braak to be positive
            select(RID)

        #Compute the jaccard coefficient for each person
        jacc_dist <- jacc_alike_coef(pre_jacc, pre_jacc_ids)

        #Compute average and SD across each DX group for each Braak
        mean_jacc <- mean(jacc_dist$avg_jack_coef, na.rm = TRUE)
        sd_jacc <- sd(jacc_dist$avg_jack_coef, na.rm = TRUE)

        #Export summary values
        jacc_by_region_sum_long <- jacc_by_region_sum_long %>%
            add_row(diagnosis = diag, braak_stage = names(tags_braak)[braaks], avg_jacc = mean_jacc, sd_jacc = sd_jacc)

        jacc_by_region_ind_long <- jacc_by_region_ind_long %>%
            add_row(RID = jacc_dist$RID, diagnosis = diag, braak_stage = names(tags_braak)[braaks], avg_jac_ind = jacc_dist$avg_jack_coef)

    }
}

```

Now that we have the cross-sectional and longitudinal Jaccard Index, we can plot both panels of Supp Figure 4.

```{r}
plot_jacc_cs <- jacc_by_region_ind %>%
    mutate(diagnosis = fct_relevel(as.factor(diagnosis), c("CU", "MCI", "AD"))) %>% #Need to force the levels to the right order
    ggplot(aes(x=braak_stage, y=avg_jac_ind, color=diagnosis)) +
    geom_boxplot(fill="white", outlier.colour=NA, position=position_dodge(width=0.9)) + #Remove outlier because we have a geom_point
    geom_point(position=position_jitterdodge(dodge.width=0.9)) +
    ylim(0,1) + #Force limit to the min/max that the Jaccard can take, so it's more comparable.
    theme_classic() + 
    scale_color_manual(values = c("#44C8F5", "#F7941D", "#ED1B2F"), limits = c("CU", "MCI", "AD"), name="Diagnosis") +
    scale_x_discrete(labels = c("Whole brain", "Braak III", "Braak IV", "Braak V\n(Frontal)", "Braak V\n(Rest)", "Braak VI")) +
    theme(panel.grid.major = element_line(), #Reimports the axis grid (1/2)
          panel.grid.minor = element_line(), #Reimports the axis gris (1/2)
          #text = element_text(size=10, family="sans"), #Imposes font family and size
          text = element_text(family="sans"), #Imposes font family and size
          axis.title.x = element_text(face="bold"), #Bolds the axis title
          axis.title.y = element_text(face="bold")) +
    xlab("Braak stage") +
    ylab("Jaccard similarity index")

plot_jacc_long <- jacc_by_region_ind_long %>%
    mutate(diagnosis = fct_relevel(as.factor(diagnosis), c("CU", "MCI", "AD"))) %>%
    ggplot(aes(x=braak_stage, y=avg_jac_ind, color=diagnosis)) +
    geom_boxplot(fill="white", outlier.colour=NA, position=position_dodge(width=0.9)) +
    geom_point(position=position_jitterdodge(dodge.width=0.9)) +
    ylim(0,1) +
    theme_classic() + #ED1B2F #F7941D
    scale_color_manual(values = c("#44C8F5", "#F7941D", "#ED1B2F"), limits = c("CU", "MCI", "AD"), name="Diagnosis") +
    scale_x_discrete(labels = c("Whole brain", "Braak III", "Braak IV", "Braak V\n(Frontal)", "Braak V\n(Rest)", "Braak VI")) +
    theme(panel.grid.major = element_line(), #Reimports the axis grid (1/2)
          panel.grid.minor = element_line(), #Reimports the axis gris (1/2)
          #text = element_text(size=10, family="sans"), #Imposes font family and size
          text = element_text(family="sans"), #Imposes font family and size
          axis.title.x = element_text(face="bold"), #Bolds the axis title
          axis.title.y = element_text(face="bold")) +
    xlab("Braak stage") +
    ylab("Jaccard similarity index")

#Patch together, with tags, collect legend and make the tag in bold.
patch_jaccard <- plot_jacc_cs + plot_jacc_long + 
    plot_annotation(tag_levels = "A") + plot_layout(guides = 'collect') & theme(plot.tag = element_text(face="bold"))

ggsave(glue("{figure_space}/suppfigure4_raw.png"), plot=patch_jaccard, width=10, height=5, dpi=500)
```

Lastly, we want to compare the values between the clinical groups. From the plot, we can already guess that the data is not normally distributed, hence, a regular ANOVA might be biased.

We can do this instead with Kruskall_Wallis and Dunn Tests. The Dunn test is the equivalent of the Tukey HSD for ANOVA when data is parametric.

```{r}
#Cross-sectional
dunn.test(jacc_by_region_ind$avg_jac_ind, jacc_by_region_ind$diagnosis, method='bonferroni', table=FALSE, list=TRUE)
#Longitudinal-sectional
dunn.test(jacc_by_region_ind_long$avg_jac_ind, jacc_by_region_ind_long$diagnosis, method='bonferroni', table=FALSE, list=TRUE)
```

In both analysis, groups were significantly different. In cross-sectional, all < 0.001, in longitudinal, CU-MCI at 0.005, AD-MCI at 0.0143 and AD-CU at < 0.001.


### 12. Supp Figure 5

Identical to figure 5 in the main text, but for executive function

```{r}
final_data_cog_ab_pos <- final_data %>%
    filter(AB_POSITIVITY_WCR == 1) %>%
    mutate(DIAGNOSIS = case_when(DIAGNOSIS == 1 ~ 'CU',
                                 DIAGNOSIS == 2 ~ 'MCI',
                                 DIAGNOSIS == 3 ~ 'AD'))

cog_meta_ef_bl <- biom_comp(final_data_cog_ab_pos, bio="meta_roi_tau_jack_tau", outcome="ADNI_EF",
                        x_lab_val="Temporal meta-ROI SUVR", lim_x_vals = c(1.0, 3.4), y_lab_val = "Executive composite score", lim_y_vals = c(-3, 3),
                        lm_diagnostics = FALSE)
cog_spex_ef_bl <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_0.5", outcome="ADNI_EF",
                        x_lab_val="Spatial Extent Index", lim_x_vals = c(0, 70), y_lab_val = "Executive composite score", lim_y_vals = c(-3, 3),
                        lm_diagnostics = FALSE)

cog_ef_bl_patch <- (cog_meta_ef_bl / cog_spex_ef_bl)

ggsave(glue("{figure_space}/suppfigure5a_raw.png"), plot=cog_ef_bl_patch, width=12, height=6, dpi=500)
```

In panel B, we want the longitudinal cognition (overtime in ADNI) with baseline tau measures.

```{r}
final_data_cog_ab_pos <- final_data %>%
    filter(AB_POSITIVITY_WCR == 1) %>%
    mutate(DIAGNOSIS = case_when(DIAGNOSIS == 1 ~ 'CU',
                                 DIAGNOSIS == 2 ~ 'MCI',
                                 DIAGNOSIS == 3 ~ 'AD'))

cog_meta_ef_long <- biom_comp(final_data_cog_ab_pos, bio="meta_roi_tau_jack_tau", outcome="annual_slope_adnief",
                        x_lab_val="Temporal meta-ROI SUVR", lim_x_vals = c(1.0, 3.4), y_lab_val = "Executive composite score decline", lim_y_vals = c(-0.43, 0.16),
                        lm_diagnostics = FALSE)
cog_spex_ef_long <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_0.5", outcome="annual_slope_adnief",
                        x_lab_val="Spatial Extent Index", lim_x_vals = c(0, 70), y_lab_val = "Executive composite score decline", lim_y_vals =  c(-0.43, 0.16),
                        lm_diagnostics = FALSE)

cog_ef_long_patch <- (cog_meta_ef_long / cog_spex_ef_long)

ggsave(glue("{figure_space}/suppfigure5b_raw.png"), plot=cog_ef_long_patch, width=12, height=6, dpi=500)
```

Next, compare performance of models using Vuong's test

```{r}
vuongtest(lm(ADNI_EF ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")),
          lm(ADNI_EF ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")))

vuongtest(lm(ADNI_EF ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")),
          lm(ADNI_EF ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")))

vuongtest(lm(ADNI_EF ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")),
          lm(ADNI_EF ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")))

vuongtest(lm(annual_slope_adnief ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")),
          lm(annual_slope_adnief ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")))

vuongtest(lm(annual_slope_adnief ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")),
          lm(annual_slope_adnief ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")))

vuongtest(lm(annual_slope_adnief ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")),
          lm(annual_slope_adnief ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")))
```

Vuong: Indicates spatial extent to be better in MCI and AD for cross-sectional data, and for MCI in longitudinal data. In longitudinal AD cognition it's the opposite.



### 13. Supp Figure 6

Same as supp figure 5, but for language

```{r}
final_data_cog_ab_pos <- final_data %>%
    filter(AB_POSITIVITY_WCR == 1) %>%
    mutate(DIAGNOSIS = case_when(DIAGNOSIS == 1 ~ 'CU',
                                 DIAGNOSIS == 2 ~ 'MCI',
                                 DIAGNOSIS == 3 ~ 'AD'))

cog_meta_lan_bl <- biom_comp(final_data_cog_ab_pos, bio="meta_roi_tau_jack_tau", outcome="ADNI_LAN",
                        x_lab_val="Temporal meta-ROI SUVR", lim_x_vals = c(1.0, 3.4), y_lab_val = "Language composite score", lim_y_vals = c(-3, 3),
                        lm_diagnostics = FALSE)
cog_spex_lan_bl <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_0.5", outcome="ADNI_LAN",
                        x_lab_val="Spatial Extent Index", lim_x_vals = c(0, 70), y_lab_val = "Language composite score", lim_y_vals = c(-3, 3),
                        lm_diagnostics = FALSE)

cog_lan_bl_patch <- (cog_meta_lan_bl / cog_spex_lan_bl)

ggsave(glue("{figure_space}/suppfigure6a_raw.png"), plot=cog_lan_bl_patch, width=12, height=6, dpi=500)
```

In panel B, we want the longitudinal cognition (overtime in ADNI) with baseline tau measures.

```{r}
final_data_cog_ab_pos <- final_data %>%
    filter(AB_POSITIVITY_WCR == 1) %>%
    mutate(DIAGNOSIS = case_when(DIAGNOSIS == 1 ~ 'CU',
                                 DIAGNOSIS == 2 ~ 'MCI',
                                 DIAGNOSIS == 3 ~ 'AD'))

cog_meta_lan_long <- biom_comp(final_data_cog_ab_pos, bio="meta_roi_tau_jack_tau", outcome="annual_slope_adnilan",
                        x_lab_val="Temporal meta-ROI SUVR", lim_x_vals = c(1.0, 3.4), y_lab_val = "Language composite score decline", lim_y_vals = c(-0.43, 0.16),
                        lm_diagnostics = FALSE)
cog_spex_lan_long <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_0.5", outcome="annual_slope_adnilan",
                        x_lab_val="Spatial Extent Index", lim_x_vals = c(0, 70), y_lab_val = "Language composite score decline", lim_y_vals =  c(-0.43, 0.16),
                        lm_diagnostics = FALSE)

cog_lan_long_patch <- (cog_meta_lan_long / cog_spex_lan_long)

ggsave(glue("{figure_space}/suppfigure6b_raw.png"), plot=cog_lan_long_patch, width=12, height=6, dpi=500)
```


```{r}
vuongtest(lm(ADNI_LAN ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")),
          lm(ADNI_LAN ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")))

vuongtest(lm(ADNI_LAN ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")),
          lm(ADNI_LAN ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")))

vuongtest(lm(ADNI_LAN ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")),
          lm(ADNI_LAN ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")))

vuongtest(lm(annual_slope_adnilan ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")),
          lm(annual_slope_adnilan ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")))

vuongtest(lm(annual_slope_adnilan ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")),
          lm(annual_slope_adnilan ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")))

vuongtest(lm(annual_slope_adnilan ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")),
          lm(annual_slope_adnilan ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")))
```

No difference, except for spatial extent being better in MCI for cross-sectional language.

```{r}
vuongtest(lm(ADNI_LAN ~ spatial_extent_thresh_2sd_cu_ab_neg, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")),
          lm(ADNI_LAN ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")))

summary(lm(scale(ADNI_LAN) ~ scale(spatial_extent_thresh_0.5), data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")))
summary(lm(scale(ADNI_LAN) ~ scale(meta_roi_tau_jack_tau), data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")))
```


### 14. Supp Figure 7

Same as previous figure, but for visuospatial.

```{r}
final_data_cog_ab_pos <- final_data %>%
    filter(AB_POSITIVITY_WCR == 1) %>%
    mutate(DIAGNOSIS = case_when(DIAGNOSIS == 1 ~ 'CU',
                                 DIAGNOSIS == 2 ~ 'MCI',
                                 DIAGNOSIS == 3 ~ 'AD'))

cog_meta_vsp_bl <- biom_comp(final_data_cog_ab_pos, bio="meta_roi_tau_jack_tau", outcome="ADNI_VSP",
                        x_lab_val="Temporal meta-ROI SUVR", lim_x_vals = c(1.0, 3.4), y_lab_val = "Visuospatial composite score", lim_y_vals = c(-3, 3),
                        lm_diagnostics = FALSE)
cog_spex_vsp_bl <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_0.5", outcome="ADNI_VSP",
                        x_lab_val="Spatial Extent Index", lim_x_vals = c(0, 70), y_lab_val = "Visuospatial composite score", lim_y_vals = c(-3, 3),
                        lm_diagnostics = FALSE)

cog_vsp_bl_patch <- (cog_meta_vsp_bl / cog_spex_vsp_bl)

ggsave(glue("{figure_space}/suppfigure7a_raw.png"), plot=cog_vsp_bl_patch, width=12, height=6, dpi=500)
```

In panel B, we want the longitudinal cognition (overtime in ADNI) with baseline tau measures.

```{r}
final_data_cog_ab_pos <- final_data %>%
    filter(AB_POSITIVITY_WCR == 1) %>%
    mutate(DIAGNOSIS = case_when(DIAGNOSIS == 1 ~ 'CU',
                                 DIAGNOSIS == 2 ~ 'MCI',
                                 DIAGNOSIS == 3 ~ 'AD'))

cog_meta_vsp_long <- biom_comp(final_data_cog_ab_pos, bio="meta_roi_tau_jack_tau", outcome="annual_slope_adnivsp",
                        x_lab_val="Temporal meta-ROI SUVR", lim_x_vals = c(1.0, 3.4), y_lab_val = "Visuospatial composite score decline", lim_y_vals = c(-0.43, 0.16),
                        lm_diagnostics = FALSE)
cog_spex_vsp_long <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_0.5", outcome="annual_slope_adnilan",
                        x_lab_val="Spatial Extent Index", lim_x_vals = c(0, 70), y_lab_val = "Visuospatial composite score decline", lim_y_vals =  c(-0.43, 0.16),
                        lm_diagnostics = FALSE)

cog_vsp_long_patch <- (cog_meta_vsp_long / cog_spex_vsp_long)

ggsave(glue("{figure_space}/suppfigure7b_raw.png"), plot=cog_vsp_long_patch, width=12, height=6, dpi=500)
```

```{r}

vuongtest(lm(ADNI_VSP ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")),
          lm(ADNI_VSP ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")))

vuongtest(lm(ADNI_VSP ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")),
          lm(ADNI_VSP ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")))

vuongtest(lm(ADNI_VSP ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")),
          lm(ADNI_VSP ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")))

vuongtest(lm(annual_slope_adnivsp ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")),
          lm(annual_slope_adnivsp ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")))

vuongtest(lm(annual_slope_adnivsp ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")),
          lm(annual_slope_adnivsp ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")))

vuongtest(lm(annual_slope_adnivsp ~ meta_roi_tau_jack_tau, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")),
          lm(annual_slope_adnivsp ~ spatial_extent_thresh_0.5, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")))

```

Trending for AD cross-sectional, but not significant.

### 15. Supp Table 1 & 2

Table 1 is the table presenting the positivity thresholds from the GMM model. Here, we simply format it so it's easier to copy to Word.

```{r}
thresholds_gmm <- read_csv(glue("{project_space}/regional_spex_thresholds.csv")) %>%
    mutate(thresh_0.5 = round(thresh_0.5, 3)) %>%
    rename("label"="...1") %>% #Rename so it's not as confusing
    mutate(label = fct_relevel(as.factor(label), levels = all_braak)) %>% #Set the labels as factors and force 
                                                                            #their order in Braak
    arrange(label) %>% 
    mutate(label = tolower(label)) %>% #Decapitalize the letters
    mutate(label = str_remove(label, "^ctx_")) %>% #Remove the prefix and suffix so it fits with ggseg nomenclature
    mutate(label = str_remove(label, "_suvr")) %>%
    separate(col = 'label', into = c('hemisphere', 'region')) %>%
    pivot_wider(id_cols = region, names_from = hemisphere, values_from = thresh_0.5)

write_csv(thresholds_gmm, file = glue("{figure_space}/supptable1_raw.csv"))

thresholds_cu <- read_csv(glue("{project_space}/cu_neg_spex_thresholds.csv")) %>%
    mutate(thresh_2sd_cu_ab_neg = round(thresh_2sd_cu_ab_neg, 3)) %>%
    rename("label"="region") %>% #Rename so it's not as confusing
    mutate(label = fct_relevel(as.factor(label), levels = all_braak)) %>% #Set the labels as factors and force 
                                                                            #their order in Braak
    arrange(label) %>% 
    mutate(label = tolower(label)) %>% #Decapitalize the letters
    mutate(label = str_remove(label, "^ctx_")) %>% #Remove the prefix and suffix so it fits with ggseg nomenclature
    mutate(label = str_remove(label, "_suvr")) %>%
    separate(col = 'label', into = c('hemisphere', 'region')) %>%
    pivot_wider(id_cols = region, names_from = hemisphere, values_from = thresh_2sd_cu_ab_neg)

write_csv(thresholds_cu, file = glue("{figure_space}/supptable2_raw.csv"))
    
```


### 16. Supp Table 3

In this table, we compute the % of positive participants for each region based on our thresholds. We divide participants in amyloid status and diagnostic group.

```{r}
ids_index <- final_data %>%
    select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5) %>% #Only keep variables we need
    #Transform the numbers to factors, which makes it easier to deal with when arranging them.
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(AB_POSITIVITY_WCR = as.factor(case_when(AB_POSITIVITY_WCR == 0 ~ "AB-",
                                         AB_POSITIVITY_WCR == 1 ~ "AB+")))

mask_regional_se_gmm <- read_csv(glue("{project_space}/long_spex_gmm_mask.csv")) 
mask_regional_se_gmm_bl<- mask_regional_se_gmm %>%
    filter(tau_pet_number == 1) %>% #Keep only baselines
    select(-c(EXAMDATE_tau, tau_pet_number)) %>% #Remove examdate and tau_pet_number (no longer useful)
    left_join(ids_index) %>% #Merge the DX, AB and tau status which we need to sort and classify
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("CU", "MCI", "AD"))) %>% #Relevel the factors in the order we want
    mutate(AB_POSITIVITY_WCR = fct_relevel(AB_POSITIVITY_WCR, c("AB+", "AB-"))) %>%
    arrange(AB_POSITIVITY_WCR) %>%
    select(-RID, -spatial_extent_thresh_0.5)

#This one counts the number of people in each group (pairs of DIAGNOSIS/AB_POSITIVITY_WCR).
#This is effectively the table header
count_by_region_and_dx_header <- mask_regional_se_gmm_bl %>%
  count(AB_POSITIVITY_WCR, DIAGNOSIS) %>%
  pivot_wider(names_from = c("DIAGNOSIS", "AB_POSITIVITY_WCR"), values_from = n)

#Same as above, but keep in long form to faciliate the percentage calculation
count_by_region_and_dx <- mask_regional_se_gmm_bl %>%
  count(AB_POSITIVITY_WCR, DIAGNOSIS) 

#This one counts the percentage of positive regions for each group
sum_by_region_and_dx <- mask_regional_se_gmm_bl %>% 
  select(DIAGNOSIS, AB_POSITIVITY_WCR, all_braak) %>% #Order the columns in Braak stages order
  group_by(AB_POSITIVITY_WCR, DIAGNOSIS) %>% #Group by diagnosis and AB status for the percentage
  summarise_all(sum) %>% #Counts the sum of positive region for each group
  ungroup() %>% #Precautionary ungroup
  left_join(count_by_region_and_dx) %>% #Merge with the count of each group (will merge by DX and AB status)
  group_by(AB_POSITIVITY_WCR, DIAGNOSIS) %>% # Grouping by diagnosis and AB again for the final percentage
  summarise(across(CTX_LH_ENTORHINAL_SUVR:CTX_RH_PRECENTRAL_SUVR, ~ round(100 * (.x / n), 1))) %>% #For all columns except DIAGNOSIS,
                                                                                          #AB, and n, calculate group percentage
  #Next, we need to pivot to a long dataframe so we can modify the region names properly
  pivot_longer(cols=CTX_LH_ENTORHINAL_SUVR:CTX_RH_PRECENTRAL_SUVR, names_to = "Regions", values_to = "%") %>%
    #We match the labels of regions to the ggseg labelling (Desikan atlas)
    mutate(Regions = tolower(Regions)) %>%
    mutate(Regions = str_remove(Regions, "^ctx_")) %>%
    mutate(Regions = str_remove(Regions, "_suvr")) %>%
    #Split the region name so hemisphere is its own region
    separate(Regions, into = c("Hemisphere", "Region"), sep="_") %>%
    #Create a new dataframe by pivoting wider so column names are DX_ABstat_hemisphere
    pivot_wider(id_cols = c(Region), names_from = c(DIAGNOSIS, AB_POSITIVITY_WCR, Hemisphere), values_from = "%")

#The file will need some modifications before the final table, but the number are all in the right place
write_csv(sum_by_region_and_dx, file = glue("{figure_space}/supptable3_raw.csv"))
```


### 17. Supp Table 4

Same thing as Supplementary Table 2, but with longitudinal progression. Specifically, we want to look at people who were negative and became positive during the follow-up.

First, we need more data preparation than the cross-sectional one:

```{r}
#Finding the variables on the participants that should be included in the analysis
ids_index <- final_data %>%
    select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5) %>% #Only keep variables we need
    #Transform the numbers to factors, which makes it easier to deal with when arranging them.
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(AB_POSITIVITY_WCR = as.factor(case_when(AB_POSITIVITY_WCR == 0 ~ "AB-",
                                         AB_POSITIVITY_WCR == 1 ~ "AB+")))

#Import binary masks
mask_regional_se_gmm <- read_csv(glue("{project_space}/long_spex_gmm_mask.csv")) 
mask_regional_se_gmm_long <- mask_regional_se_gmm %>%
    group_by(RID) %>% #We want longitudinal, so we need to figure out longitudinal visits for each RID
    filter(n_distinct(tau_pet_number) >= 2) %>% #Keep only people with 2 or more visits
    filter(row_number() == 1 | row_number()==n()) %>% #For each participant, keep the first and last row
    select(-c(EXAMDATE_tau)) %>% #Removing useless column
    left_join(ids_index) %>% #Merge the diagnosis and amyloid positivity information
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("CU", "MCI", "AD"))) %>% #Relevel diagnoses so AD will be at the bottom and AD at the top of the heatmap
    mutate(AB_POSITIVITY_WCR = fct_relevel(AB_POSITIVITY_WCR, c("AB+", "AB-"))) %>% #Relevel AB positivity so AB+ are together
    #Next, we pivot to a long format
    pivot_longer(cols = -c(RID, DIAGNOSIS, tau_pet_number, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), names_to="regions", values_to = "posit") %>%
    mutate(first_last_tag = ifelse(tau_pet_number == 1, "First", "Last")) %>% #For each participant, we tag the first observation as "First" and the second as "Last"
    #Next, we need to flip back to a wide format, so for each region, of each individual, we have the score for the first and last visit in two columns
    pivot_wider(id_cols = c(RID, regions, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5), values_from = c(posit), names_from = c(first_last_tag)) %>%
    #We substract the first and last visits to get the conversion status
    mutate(first_minus_last = First - Last) %>%
    #Next, we change the "first_minus_last" to a proper conversion variable. For this table, we care only about 0 or 1
    mutate(conversion = case_when(first_minus_last == -1 ~ 1, 
                                  TRUE ~ 0)) %>%
    mutate(regions = as.factor(regions)) %>% #Convert the regions 
    mutate(regions = fct_relevel(regions, all_braak)) %>%
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, regions, -spatial_extent_thresh_0.5) %>%
    ungroup() %>%
    select(-c(spatial_extent_thresh_0.5, First, Last, first_minus_last)) %>%
    #We need to flip it one last time to wide, to properly compute what we need.
    pivot_wider(id_cols = c(RID, DIAGNOSIS, AB_POSITIVITY_WCR), names_from = regions, values_from = conversion) %>%
    select(-RID)
```

Now we create the table like in the previous section.

```{r}
#This one counts the number of people in each group (pairs of DIAGNOSIS/AB_POSITIVITY_WCR).
#This is effectively the table header
count_by_region_and_dx_header <- mask_regional_se_gmm_long %>%
  count(AB_POSITIVITY_WCR, DIAGNOSIS) %>%
  pivot_wider(names_from = c("DIAGNOSIS", "AB_POSITIVITY_WCR"), values_from = n)

#Same as above, but keep in long form to faciliate the percentage calculation
count_by_region_and_dx <- mask_regional_se_gmm_long %>%
  count(AB_POSITIVITY_WCR, DIAGNOSIS) 

#This one counts the percentage of positive regions for each group
sum_by_region_and_dx_long <- mask_regional_se_gmm_long %>% 
  select(DIAGNOSIS, AB_POSITIVITY_WCR, all_braak) %>% #Order the columns in Braak stages order
  group_by(AB_POSITIVITY_WCR, DIAGNOSIS) %>% #Group by diagnosis and AB status for the percentage
  summarise_all(sum) %>% #Counts the sum of positive region for each group
  ungroup() %>% #Precautionary ungroup
  left_join(count_by_region_and_dx) %>% #Merge with the count of each group (will merge by DX and AB status)
  group_by(AB_POSITIVITY_WCR, DIAGNOSIS) %>% # Grouping by diagnosis and AB again for the final percentage
  summarise(across(CTX_LH_ENTORHINAL_SUVR:CTX_RH_PRECENTRAL_SUVR, ~ round(100 * (.x / n), 1))) %>% #For all columns except DIAGNOSIS,
                                                                                          #AB, and n, calculate group percentage
  #Next, we need to pivot to a long dataframe so we can modify the region names properly
  pivot_longer(cols=CTX_LH_ENTORHINAL_SUVR:CTX_RH_PRECENTRAL_SUVR, names_to = "Regions", values_to = "%") %>%
    #We match the labels of regions to the ggseg labelling (Desikan atlas)
    mutate(Regions = tolower(Regions)) %>%
    mutate(Regions = str_remove(Regions, "^ctx_")) %>%
    mutate(Regions = str_remove(Regions, "_suvr")) %>%
    #Split the region name so hemisphere is its own region
    separate(Regions, into = c("Hemisphere", "Region"), sep="_") %>%
    #Create a new dataframe by pivoting wider so column names are DX_ABstat_hemisphere
    pivot_wider(id_cols = c(Region), names_from = c(DIAGNOSIS, AB_POSITIVITY_WCR, Hemisphere), values_from = "%")

#The file will need some modifications before the final table, but the number are all in the right place
write_csv(sum_by_region_and_dx_long, file = glue("{figure_space}/supptable4_raw.csv"))
```

#####################

### Reviewer comments

All previous sections followed code from the original manuscript and associated figures. The following code was used to respond to reviewer queries during the revision process. The following comments were addressed in text and did not need new methods:

R1: C1.1, C1.2, C1.4
R2: C2.1, C2.3, C2.4, C2.7, C2.8, C2.11, C2.13, C2.16, C2.17, C2.18

#### R1: C. 1.3

R1 is asking us to consider other factors that may be associated with heterogeneity in tau (i.e., spatial extent index), specifically demographics

To address this, we can look at the association between the spatial extent and different demographic variables (Age, Sex, Education and ApoE). 

##### Supp Figure 8

This mimics Figure 5, but with age instead of a cognitive measure.

```{r}
final_data_cog_ab_pos <- final_data %>%
    filter(AB_POSITIVITY_WCR == 1) %>%
    mutate(DIAGNOSIS = case_when(DIAGNOSIS == 1 ~ 'CU',
                                 DIAGNOSIS == 2 ~ 'MCI',
                                 DIAGNOSIS == 3 ~ 'AD'))

#max(final_data$PTAGE) #To get the limits the graphs should have
#min(final_data$PTAGE)
#max(final_data$PTEDUCAT)
#min(final_data$PTEDUCAT)

spex_age <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_0.5", outcome="PTAGE",
                        x_lab_val="Spatial Extent Index", lim_x_vals = c(0, 70), y_lab_val = "Age", lim_y_vals = c(50,95),
                        lm_diagnostics = FALSE)
meta_roi_age <- biom_comp(final_data_cog_ab_pos, bio="meta_roi_tau_jack_tau", outcome="PTAGE",
                        x_lab_val="Temporal meta-ROI SUVR", lim_x_vals = c(1, 3.5), y_lab_val = "Age", lim_y_vals = c(50,95),
                        lm_diagnostics = FALSE)

tau_age <- (meta_roi_age / spex_age)

ggsave(glue("{figure_space}/suppfigure8_raw.png"), plot=tau_age, width=12, height=6, dpi=500)

```

For Gender, education and ApoE, we will simply run local models (no figures). We will use linear models for all. 

```{r}
#Run the models separately for each clinical group
cu_data <- final_data_cog_ab_pos %>% filter(DIAGNOSIS == "CU")
mci_data <- final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")
ad_data <- final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")

```


```{r}
#Apoe
summary(lm(spatial_extent_thresh_0.5 ~ apoe_bin, data=cu_data)) #No effect
summary(lm(scale(spatial_extent_thresh_0.5) ~ apoe_bin + scale(PTAGE) + scale(PTEDUCAT) + as.factor(PTGENDER), data=mci_data %>% mutate(apoe_bin = as.factor(fct_relevel(apoe_bin, c('non_E4', 'E4')))))) #Minimal effect
summary(lm(scale(meta_roi_tau_jack_tau) ~ apoe_bin + scale(PTAGE) + scale(PTEDUCAT) + as.factor(PTGENDER), data=mci_data %>% mutate(apoe_bin = as.factor(fct_relevel(apoe_bin, c('non_E4', 'E4')))))) #Minimal effect
summary(lm(spatial_extent_thresh_0.5 ~ apoe_bin, data=ad_data)) #No effect

#Gender
summary(lm(spatial_extent_thresh_0.5 ~ as.factor(PTGENDER), data=cu_data)) #No effect
summary(lm(spatial_extent_thresh_0.5 ~ as.factor(PTGENDER), data=mci_data)) #No effect
summary(lm(spatial_extent_thresh_0.5 ~ as.factor(PTGENDER), data=ad_data)) #No effect


#Education
summary(lm(spatial_extent_thresh_0.5 ~ PTEDUCAT, data=cu_data)) #No effect
summary(lm(spatial_extent_thresh_0.5 ~ PTEDUCAT, data=mci_data)) #No effect
summary(lm(spatial_extent_thresh_0.5 ~ PTEDUCAT, data=ad_data)) #No effect
```

#### R2: C. 2.3

R2 asks whether cut-points using different methods would likely affect positivity thresholds, and whether these other methods affect our results. 

Thresholds differ between cohorts, because the samples used to generate the thresholds will also change. A common method to create thresholds is to use the mean plus 2 standard deviations (95%) to deviate from a sample of CU AB- (who are likely not on the path to AD; Jack 2017, Ossenk 2022, Strikwerda-Brown 2022). In this section, we compare the two methods in ADNI.

##### Supp Figure 9

How sensitive are thresholds in each method sensitive to the distribution of the data? The idea is that if the CU AB- are influenced by the skewdness of the distribution--but not as much for GMM--then it can confirm why GMM might better capture tau accumulation associated with the disease.

For instance, we know that the distribution of values in certain region is lower. The SD method is likely sensitive to the spread of the data (data with less spread will likely have lower thresholds). 

For that, we will compute different metrics from the SUVR data of CU AB- and relate it to the thresholds from either method.

```{r}
#First, get the IDs and the diagnostic/amyloid information
ids_index <- final_data %>%
    select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_2sd_cu_ab_neg) %>% #Only keep variables we need
    #Transform the numbers to factors, which makes it easier to deal with when arranging them.
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(AB_POSITIVITY_WCR = as.factor(case_when(AB_POSITIVITY_WCR == 0 ~ "AB-",
                                         AB_POSITIVITY_WCR == 1 ~ "AB+")))

#Then, we clean the SUVR and merge with the diagnosis and AB
mask_map_regional_suvr <- read_csv(glue("{project_space}/suvr_values_long.csv")) 
mask_map_regional_suvr_bl <- mask_map_regional_suvr %>%
    filter(tau_pet_number == 1) %>% #Keep only baselines
    select(-c(EXAMDATE_tau, tau_pet_number)) %>% #Remove examdate and tau_pet_number (no longer useful)
    left_join(ids_index) %>%
    select(-RID)

#Next, we compute our measures
cu_ab_neg_data <- mask_map_regional_suvr_bl %>%
    filter(DIAGNOSIS == "CU") %>% #Restrict to CU
    filter(AB_POSITIVITY_WCR == "AB-") %>% #Restrict to AB-
    select(-c(DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_2sd_cu_ab_neg)) %>% #Remove variables no longer useful
    #We then want a dataframe in long format (it really facilitates the summarize)
    pivot_longer(cols = everything(), names_to="Regions", values_to="suvr") %>%
    group_by(Regions) %>% #Group by regions so you outputs stats by region
    #We get the mean, sd, IQR (initial step) and range
    summarize_all(c(~ mean(.x), ~sd(.x), ~IQR(.x), ~(max(.x) - min(.x)), ~quantile(.x, probs=0.25, na.rm=TRUE), ~quantile(.x, probs=0.75, na.rm=TRUE))) %>%
    #Next, to color our graph, we identify the Braak stages of each region
    mutate(braak_stage = case_when(Regions %in% braak_1_regs ~ 'Braak I',
                                   Regions %in% braak_3_regs ~ 'Braak III',
                                   Regions %in% braak_4_regs ~ 'Braak IV',
                                   Regions %in% braak_5_front_regs ~ 'Braak Vf',
                                   Regions %in% braak_5_rest_regs ~ 'Braak Vr',
                                   Regions %in% braak_6_regs ~ 'Braak VI')) %>%
    #Reorder the factors to the right order
    mutate(braak_stage = fct_relevel(as.factor(braak_stage), 
                                     c('Braak I', "Braak III", "Braak IV", "Braak Vf", "Braak Vr", "Braak VI"))) %>%
    mutate(Regions = tolower(Regions)) %>%
    mutate(Regions = str_remove(Regions, "^ctx_")) %>%
    mutate(Regions = str_remove(Regions, "_suvr")) %>%
    rename('label'="Regions", 'range'='(',
           'quantile25'='quantile..5', 
           'quantile75'='quantile..6') %>% #correct the names to match with the next dataframe + be informative
    mutate(low_iqr = quantile25 - 1.5*IQR) %>%
    mutate(high_iqr = quantile75 + 1.5*IQR) %>%
    mutate(iqr_range = high_iqr - low_iqr) #Calculate the IQR here
    
#Next, import the actual thresholds
thresh_gmm <- read_csv(glue("{project_space}/regional_spex_thresholds.csv"))
thresh_cuneg <- read_csv(glue("{project_space}/cu_neg_spex_thresholds.csv"))

#Clean the thresholds
thresh_gmm_clean <- thresh_gmm %>%
    rename("Regions"=`...1`) %>% #Adjust the name
    mutate(Regions = tolower(Regions)) %>% 
    mutate(Regions = str_remove(Regions, "^ctx_")) %>%
    mutate(Regions = str_remove(Regions, "_suvr"))

thresh_cuneg_clean <- thresh_cuneg %>%
    rename("Regions"='region') %>% #Match the name to the other one
    mutate(Regions = tolower(Regions)) %>%
    mutate(Regions = str_remove(Regions, "^ctx_")) %>%
    mutate(Regions = str_remove(Regions, "_suvr"))

thresh_all <- thresh_gmm_clean %>%
    left_join(thresh_cuneg_clean) %>% #Merge the thresholds
    #Compute the numerical and the percent difference between the thresholds (percent difference is easier to understand)
    mutate(diff_thresh = thresh_0.5 - thresh_2sd_cu_ab_neg) %>%
    mutate(perc_change = (abs(thresh_0.5 - thresh_2sd_cu_ab_neg) / ((thresh_0.5 + thresh_2sd_cu_ab_neg) / 2)) * 100) %>%
    rename('label'="Regions") %>%
    left_join(cu_ab_neg_data) %>% #Merge the SUVR spread data
    separate(col = label, into = c("hemisphere", NA), sep='_', remove=FALSE) #Get the hemisphere for the plotting
```

Ok, let's start with a simple paired t-test
```{r}
t.test(thresh_all$thresh_0.5, thresh_all$thresh_2sd_cu_ab_neg, paired=TRUE)
```

On average, SUVR from the GMM are 0.10 higher than when from CU AB-. Though, this isn't super informative because the range of SUVR values can differ greatly between regions.

Let's check if the thresholds from both methods are associated with specific characteristics of the spread of SUVR data.

```{r}
cor.test(thresh_all$thresh_0.5, thresh_all$mean) #0.8867635 # < 0.001
cor.test(thresh_all$thresh_0.5, thresh_all$sd) #0.4605351 # < 0.001
cor.test(thresh_all$thresh_0.5, thresh_all$range) #0.3083327 #0.009
cor.test(thresh_all$thresh_0.5, thresh_all$IQR) #0.2976609 #0.012

cor.test(thresh_all$thresh_2sd_cu_ab_neg, thresh_all$mean) #0.9459702 # < 0.001
cor.test(thresh_all$thresh_2sd_cu_ab_neg, thresh_all$sd) #0.7459847 # < 0.001
cor.test(thresh_all$thresh_2sd_cu_ab_neg, thresh_all$range) #0.6569583 # < 0.001
cor.test(thresh_all$thresh_2sd_cu_ab_neg, thresh_all$IQR) #0.3246673 #0.006

cor.test(thresh_all$thresh_2sd_cu_ab_neg, thresh_all$thresh_0.5) #0.9459702 # < 0.001

cor.test(thresh_all$perc_change, thresh_all$mean) 
cor.test(thresh_all$perc_change, thresh_all$sd)
cor.test(thresh_all$perc_change, thresh_all$range) #-0.7028562
cor.test(thresh_all$perc_change, thresh_all$IQR) 
```

Looks like the data is mostly affected by SUVR distributions with outliers with a lot of tau. When we restrict to the IQR, both thresholds are associated with the IQR in the same way, and the IQR is pretty much the same across regions. We can compare this by comparing the association between each threshold method and the range of the SUVR in each region. We can compare the correlations using a z-test.

```{r}
cor.test(thresh_all$thresh_0.5, thresh_all$thresh_2sd_cu_ab_neg) #0.8486155 #Needed info for cocor

#We use the simple Z-test, but the results were the same across methods (Pearson and Filon's z (1898))

cocor.dep.groups.overlap(r.jk=0.3083327, r.jh=0.6569583, r.kh=0.8486155, n=70, alternative="less", alpha=0.05, conf.level=0.95, null.value=0) #Strong difference 
cocor.dep.groups.overlap(r.jk=0.2976609, r.jh=0.3246673, r.kh=0.8486155, n=70, alternative="less", alpha=0.05, conf.level=0.95, null.value=0) #No difference
```

Thresholds of both methods are similarly associated with the interquartile range (i.e., the interquartile range doesn't differ much from region to region), but are differently associated with the range of the data. Concretly, the CU method is more associated (i.e., sensitive) to the range of the data than the GMM. We can plot all of these differences

First, we can plot this on a brain template. Then, we can compare the thresholds depending on the range of the data.

```{r}
ggseg_plot_thresh_diff <- ggplot(thresh_all) +
        geom_brain(atlas=dk, #Desikan atlas
                   color='white', #Color of the borders between regions
                   position=position_brain(hemi ~ side), #Position of the brain (2 rows, side and middle, side and middle)
                   aes(fill = perc_change)) + #Fill the regions by the value of interest
        #Add two points for the amygdalas. The position was determined from the plot before adding theme_void()
        #Amygdalas are not added by default because it is not cortical, so the position is approximate
        geom_point(data = subset(thresh_all, label %in% c("lh_amygdala")), aes(548, y=29, fill=diff_thresh), shape=21, color="white", size=3.5) +
        geom_point(data = subset(thresh_all, label %in% c("rh_amygdala")), aes(490, y=275, fill=diff_thresh), shape=21, color="white", size=3.5) +
        theme_void() + #Remove all axis
        scale_fill_viridis_c(option="plasma", na.value="grey", name="Relative\nDifference (%)") + #Colors the plot
        theme(plot.title = element_text(hjust = 0.5, face='bold', size=18),
              legend.position = "right")

suvr_threshs <- thresh_all %>%
    ggplot(aes(x=thresh_2sd_cu_ab_neg, y=thresh_0.5)) + #Plot the thresholds of both methods
    stat_smooth(method = "lm", color="#44C8F5", fill="#44C8F5", alpha=0.1) + #LM between thresholds
    geom_point(aes(color=braak_stage, shape=hemisphere), size=2) + #Each point is a region, colored by Braak stage
    scale_shape_manual(values = c(16,17), name="Hemisphere", labels = c("Left", "Right")) +
    #Color by viridis for ease of browsing
    scale_fill_viridis_d(option="D", direction=-1, name='Braak stage', aesthetics = c("fill", "color")) +
    theme_classic() +
    xlim(c(1.1, 1.6)) + #Match the limits of both thresholding methods
    ylim(c(1.1, 1.6)) +
    xlab("Threshold (2SD from CU A\U03B2-)") +
    ylab("Threshold (50% probability GMM-derived)") +
    annotate("text", y=-Inf, x =Inf, vjust=-0.5, hjust=1,  #We add the stats information on the graph
           label=glue("r = 0.85 ***")) +
    theme(
        panel.grid.major = element_line(), #Reimports the axis grid (1/2)
        panel.grid.minor = element_line(), #Reimports the axis gris (1/2)
        #text = element_text(size=10, family="sans"), #Imposes font family and size
        text = element_text(family="sans"), #Imposes font family and size
        axis.title.x = element_text(face="bold"), #Bolds the axis title
        axis.title.y = element_text(face="bold")) #Ensures a square is outputted

#In this one, we plot the range of CU AB- values and the thresholds from GMM
suvr_range_thresh_05 <- thresh_all %>%
    ggplot(aes(x=range, y=thresh_0.5)) +
    stat_smooth(method = "lm", color="#44C8F5", fill="#44C8F5", alpha=0.1) +
    geom_point(aes(color=braak_stage, shape=hemisphere), size=2) +
    scale_shape_manual(values = c(16,17), name="Hemisphere", labels = c("Left", "Right")) +
    scale_fill_viridis_d(option="D", direction=-1, name='Braak stage', aesthetics = c("fill", "color")) +
    theme_classic() +
    ylim(c(1.1, 1.6)) +
    xlab("Range of regional tau-PET SUVR data") +
    ylab("Threshold (50% probability GMM-derived)") +
    annotate("text", y=-Inf, x =Inf, vjust=-0.5, hjust=1,  #We add the stats information on the graph
           label=glue("r = 0.31 **")) +
    theme(
        panel.grid.major = element_line(), #Reimports the axis grid (1/2)
        panel.grid.minor = element_line(), #Reimports the axis gris (1/2)
        #text = element_text(size=10, family="sans"), #Imposes font family and size
        text = element_text(family="sans"), #Imposes font family and size
        axis.title.x = element_text(face="bold"), #Bolds the axis title
        axis.title.y = element_text(face="bold")) #Ensures a square is outputted

suvr_range_thresh_cuneg <- thresh_all %>%
    ggplot(aes(x=range, y=thresh_2sd_cu_ab_neg)) +
    stat_smooth(method = "lm", color="#44C8F5", fill="#44C8F5", alpha=0.1) +
    geom_point(aes(color=braak_stage, shape=hemisphere), size=2) +
    scale_shape_manual(values = c(16,17), name="Hemisphere", labels = c("Left", "Right")) +
    scale_fill_viridis_d(option="D", direction=-1, name='Braak stage', aesthetics = c("fill", "color")) +
    theme_classic() +
     ylim(c(1.1, 1.6)) +
    xlab("Range of regional tau-PET SUVR data") +
    ylab("Threshold (2SD from CU A\U03B2-)") +
    annotate("text", y=-Inf, x =Inf, vjust=-0.5, hjust=1,  #We add the stats information on the graph
           label=glue("r = 0.66 ***")) +
    theme(
        panel.grid.major = element_line(), #Reimports the axis grid (1/2)
        panel.grid.minor = element_line(), #Reimports the axis gris (1/2)
        #text = element_text(size=10, family="sans"), #Imposes font family and size
        text = element_text(family="sans"), #Imposes font family and size
        axis.title.x = element_text(face="bold"), #Bolds the axis title
        axis.title.y = element_text(face="bold")) #Ensures a square is outputted

#Patch everything together and output
patch_supp_fig9 <- ggseg_plot_thresh_diff / (suvr_threshs + suvr_range_thresh_05 + suvr_range_thresh_cuneg + plot_layout(guides = "collect")) + plot_layout(widths = c(4, 10), heights = c(4.5, 4)) + plot_annotation(tag_levels = "A") & theme(plot.tag = element_text(face='bold', size=24))

ggsave(glue("{figure_space}/suppfigure9_raw.png"), plot=patch_supp_fig9, height=8, width = 12, dpi=500)
```




#### R2: C. 2.5

R2 wanted to see the thresholds of the Braak stages and wondered if the participants would still follow the stages when using the CU AB- method discussed in 2.3.

Then, we redid some major analyses in the manuscript to confirm whether these thresholds majorily affected the results.

##### Supp Table 5 - Braak Stages - Cutoffs

Here, we want to report the cutoffs used for the Braak stages using both methods.

```{r}
thresh_braak_gmm <- read_csv(glue("{project_space}/braak_spex_thresholds.csv")) %>% rename('region'='...1')
thresh_braak_cu <- read_csv(glue("{project_space}/braak_cuneg_spex_thresholds.csv")) %>% filter(region != 'meta_roi_ab_ozlen')
```

Then, we can just merge them together:

```{r}
final_threshs_braak <- full_join(thresh_braak_gmm, thresh_braak_cu)
write_csv(final_threshs_braak, file = glue("{figure_space}/supptable5_raw.csv"))

```


##### Supp Figure 10 

Now, let's redo the proportion of AT groups (same as Figure 2)

```{r}
#First, isolate and prepare the data for the pie charts
pie_chart_data <- final_data %>%
    mutate(se_status = case_when(spatial_extent_thresh_2sd_cu_ab_neg > 0 ~ 1, #When spatial extent is above 0, then positive
                                 TRUE ~ 0)) %>%
    select(AB_POSITIVITY_WCR, se_status, DIAGNOSIS) %>% #Select only the columns we need
    group_by(DIAGNOSIS, AB_POSITIVITY_WCR, se_status) %>% #Group participants by diagnosis, AB status and tau status
    summarize(cnt=n()) %>% #Count the total number by each se status
    ungroup() %>%
    group_by(DIAGNOSIS) %>% #Group by diagnosis to do the %
    mutate(freq_by_ab_se = cnt / sum(cnt)) %>%
    ungroup() %>%
    unite(ab_se_group, c(AB_POSITIVITY_WCR, se_status)) %>% #Merge AB status and tau status in a single variable for plotting
    mutate(ab_se_group = fct_relevel(as.factor(ab_se_group), c("1_1", "1_0", "0_1", "0_0"))) #AT status in order

pie_data_cu <- pie_chart_data %>%
    filter(DIAGNOSIS == 1) %>% #1 == CU
    mutate(cum_count_y = as.integer(cumsum(cnt))) %>% #Count the cumulative count (needed for the position on the pie chart)
    mutate(position_y = cum_count_y - (cnt*0.5)) #Find the actual position for that section of the piechart

pie_data_mci <- pie_chart_data %>%
    filter(DIAGNOSIS == 2) %>% #2 == MCI
    mutate(cum_count_y = as.integer(cumsum(cnt))) %>%
    mutate(position_y = cum_count_y - (cnt*0.5))

pie_data_ad <- pie_chart_data %>%
    filter(DIAGNOSIS == 3) %>% #3 == AD
    mutate(cum_count_y = as.integer(cumsum(cnt))) %>%
    mutate(position_y = cum_count_y - (cnt*0.5))
```

Then, create the graphs

```{r}
#Cognitively unimpaired
at_group_cu <- pie_data_cu %>%
 ggplot() +
 geom_col(aes(x=1, y=cnt, fill=ab_se_group), position = "stack") + #A pie chart is actually a column graph + coord_polar
 scale_fill_viridis_d(option="inferno", name="AT group", direction=-1, labels=c("A+T+", "A+T-", "A-T+", "A-T-")) +
 geom_text(aes(x=1.0, y=115.5, label="n=231\n(49.8%)"), color="white") +
 geom_text(aes(x=1.1, y=265.5, label="n=69\n(14.9%)"), color="white") +
 geom_text(aes(x=1.1, y=339.0, label="n=78\n(16.8%)"), color="white") +
 geom_text(aes(x=1.1, y=420.5, label="n=85\n(18.4%)"), color="black") +
 coord_polar(theta = "y") + #This is the line that transforms columns to pie chart
 theme_void() +
 ggtitle("Cognitively unimpaired") +
    theme(plot.title = element_text(face="bold", size=17, hjust=0.5, vjust=-1))

#at_group_cu

#Mild cognitive impairment
at_group_mci <- pie_data_mci %>%
  ggplot() +
  geom_col(aes(x=1, y=cnt, fill=ab_se_group), position = "stack") +
  scale_fill_viridis_d(option="inferno", name="AT group", direction=-1, labels=c("A+T+", "A+T-", "A-T+", "A-T-")) +
  geom_text(aes(x=1.1, y=50, label="n=98\n(35.4%)"), color="white") +
  geom_text(aes(x=1.1, y=121.5, label="n=47\n(16.9%)"), color="white") +
  geom_text(aes(x=1.25, y=154.0, label="n=18\n(6.50%)"), color="white") +
  geom_text(aes(x=1.0, y=227.0, label="n=114\n(41.1%)"), color="black") +
  coord_polar(theta = "y") +
  theme_void() +
    ggtitle("Mild cognitive impairment") +
    theme(plot.title = element_text(face="bold", size=17, hjust=0.5, vjust=-1))

#at_group_mci

#Alzheimer's disease
at_group_ad <- pie_data_ad %>%
 ggplot() +
 geom_col(aes(x=1, y=cnt, fill=ab_se_group), position = "stack") +
 scale_fill_viridis_d(option="inferno", name="AT group", direction=-1, labels=c("A+T+", "A+T-", "A-T+", "A-T-")) +
 #scale_fill_manual(values=c("#FDFDA4","#EE6924","#FBFBFB","#FBFBFB"), name="AT group", labels=c("A+T+", "A+T-", "A-T+", "A-T-")) + #Merged AB- stats in grey
 geom_text(aes(x=1.24, y=3.5, label="n=7\n(7.6%)"), color="white") +
 geom_text(aes(x=1.24, y=10.5, label="n=8\n(8.7%)"), color="white") +
 geom_text(aes(x=1.24, y=17.5, label="n=5\n(5.4%)"), color="white") +
 geom_text(aes(x=1.0, y=56.0, label="n=72\n(78.3%)"), color="black") +
 coord_polar(theta = "y") +
 theme_void() +
    ggtitle("Alzheimer's disease") +
    theme(plot.title = element_text(face="bold", size=17, hjust=0.5, vjust=-1))

#at_group_ad

#Patch the plots together
pie_patch <- at_group_cu + at_group_mci + at_group_ad + plot_layout(guides = "collect")

#Save the plot
ggsave(glue("{figure_space}/suppfigure10_raw.png"), plot=pie_patch, height=4, width = 12, dpi=500)
```

We can finally do a proportion test to check whether the CU AB- significantly changed some of our groups.

```{r}
#Since we are checking if the proportion change but we have the same participants for each, we need to use McNemar.

#Prep data
prop_pos_data <- final_data %>%
    select(RID, DIAGNOSIS, spatial_extent_thresh_0.5, AB_POSITIVITY_WCR, spatial_extent_thresh_2sd_cu_ab_neg) %>%
    #We create proportions to check: People are A+T+ if spex > 0 and AB == 1. People are A-T+ if spex > 0 but AB == 0
    mutate(aptp_gmm_thresh = case_when((spatial_extent_thresh_0.5 > 0 & AB_POSITIVITY_WCR == 1) ~ 1,
                                  TRUE ~ 0)) %>%
    mutate(antp_gmm_thresh = case_when((spatial_extent_thresh_0.5 > 0 & AB_POSITIVITY_WCR == 0) ~ 1,
                                  TRUE ~ 0)) %>%
    mutate(aptp_cu_thresh = case_when((spatial_extent_thresh_2sd_cu_ab_neg > 0 & AB_POSITIVITY_WCR == 1) ~ 1,
                                  TRUE ~ 0)) %>%
    mutate(antp_cu_thresh = case_when((spatial_extent_thresh_2sd_cu_ab_neg > 0 & AB_POSITIVITY_WCR == 0) ~ 1,
                                  TRUE ~ 0)) %>%
    #Last, we want to check if the proportion changing for aptp is different from the proportion changing in aptn.
    mutate(aptp_change = case_when(aptp_gmm_thresh != aptp_cu_thresh ~ 1,
                                   TRUE ~ 0)) %>%
    mutate(antp_change = case_when(antp_gmm_thresh != antp_cu_thresh ~ 1,
                                   TRUE ~ 0))
    

#Restrict to the diagnosis groups
cu_prop_pos_data <- prop_pos_data %>%
    filter(DIAGNOSIS == 1)

mci_prop_pos_data <- prop_pos_data %>%
    filter(DIAGNOSIS == 2)

ad_prop_pos_data <- prop_pos_data %>%
    filter(DIAGNOSIS == 3)


#McNemar tests
## CU participants
mcnemar.test(x = cu_prop_pos_data$aptp_gmm_thresh, y=cu_prop_pos_data$aptp_cu_thresh) #Signif
mcnemar.test(x = cu_prop_pos_data$antp_gmm_thresh, y=cu_prop_pos_data$antp_cu_thresh) #Signif

mcnemar.test(x = cu_prop_pos_data$aptp_change, y=cu_prop_pos_data$antp_change) #Signif

## MCI participants
mcnemar.test(x = mci_prop_pos_data$aptp_gmm_thresh, y=mci_prop_pos_data$aptp_cu_thresh) #Signif
mcnemar.test(x = mci_prop_pos_data$antp_gmm_thresh, y=mci_prop_pos_data$antp_cu_thresh) #Signif

mcnemar.test(x = mci_prop_pos_data$aptp_change, y=mci_prop_pos_data$antp_change) #Not signif

## AD participants
mcnemar.test(x = ad_prop_pos_data$aptp_gmm_thresh, y=ad_prop_pos_data$aptp_cu_thresh) #No difference
mcnemar.test(x = ad_prop_pos_data$antp_gmm_thresh, y=ad_prop_pos_data$antp_cu_thresh) #No difference


```


##### Supp Figure 11

This one replicates the heatmap from Figure 3 and whether people follow the Braak stages.

```{r}
#Finding the variables on the participants that should be included in the analysis
ids_index <- final_data %>%
    select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_2sd_cu_ab_neg) %>% #Only keep variables we need
    #Transform the numbers to factors, which makes it easier to deal with when arranging them.
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(AB_POSITIVITY_WCR = as.factor(case_when(AB_POSITIVITY_WCR == 0 ~ "AB-",
                                         AB_POSITIVITY_WCR == 1 ~ "AB+")))

#Import binary masks 
mask_regional_se_cuneg <- read_csv(glue("{project_space}/long_spex_cu_neg_mask.csv")) 
mask_regional_se_cuneg_bl<- mask_regional_se_cuneg %>%
    filter(tau_pet_number == 1) %>% #Keep only baselines
    select(-c(EXAMDATE_tau, tau_pet_number)) %>% #Remove examdate and tau_pet_number (no longer useful)
    left_join(ids_index) %>% #Merge the DX, AB and tau status which we need to sort and classify
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("AD", "MCI", "CU"))) %>% #Relevel the factors in the order we want
    mutate(AB_POSITIVITY_WCR = fct_relevel(AB_POSITIVITY_WCR, c("AB-", "AB+"))) %>%
    group_by(DIAGNOSIS, AB_POSITIVITY_WCR) %>% #We group by diagnosis and AB positivity status
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, -spatial_extent_thresh_2sd_cu_ab_neg) %>% #We arrange participants by diagnosis, positivity and spatial extent (this last one, from highest to lowest to the bars all go to the bottom of each section)
    #Pivot to a long format. This is needed for ggplot to understand that the regions are the x-axis of the heatmap
    pivot_longer(cols = -c(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_2sd_cu_ab_neg), names_to="regions", values_to = "spex") %>%
    mutate(regions = as.factor(regions)) %>% #Make regions as factor
    mutate(regions = fct_relevel(regions, all_braak)) %>% #Make sure regions are in the Braak order
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, regions, -spatial_extent_thresh_2sd_cu_ab_neg) %>% #Final sort, making sure the regions will show up in Braak order
    ungroup()

#Repeat the same process for the Braak stages
#Import binary masks
mask_braak_se_cuneg <- read_csv(glue("{project_space}/long_spex_cu_neg_braak_mask.csv")) 
mask_braak_se_cuneg_bl <- mask_braak_se_cuneg %>%
    select(-c(meta_roi_tau_jack, meta_roi_ab_ozlen)) %>%
    filter(tau_pet_number == 1) %>%
    select(-c(EXAMDATE_tau, tau_pet_number)) %>%
    left_join(ids_index) %>%
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("AD", "MCI", "CU"))) %>%
    mutate(AB_POSITIVITY_WCR = fct_relevel(AB_POSITIVITY_WCR, c("AB-", "AB+"))) %>%
    group_by(DIAGNOSIS, AB_POSITIVITY_WCR) %>%
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, -spatial_extent_thresh_2sd_cu_ab_neg) %>%
    pivot_longer(cols = -c(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_2sd_cu_ab_neg), names_to="regions", values_to = "spex") %>%
    mutate(regions = as.factor(regions)) %>%
    arrange(DIAGNOSIS, AB_POSITIVITY_WCR, regions, -spatial_extent_thresh_2sd_cu_ab_neg) %>%
    ungroup()

```

```{r}
follow_braak_cs <- mask_braak_se_cuneg_bl %>%
    filter(AB_POSITIVITY_WCR == "AB+") %>%
    pivot_wider(id_cols=c(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_2sd_cu_ab_neg), names_from = regions, values_from=spex) %>%
    select(-c(AB_POSITIVITY_WCR, spatial_extent_thresh_2sd_cu_ab_neg))


follow_braak_cs %>% filter(braak6_suvr == 1) %>% mutate(follows = case_when(
    braak5_suvr == 1 & braak4_suvr == 1 & braak3_suvr == 1 & braak1_suvr == 1 ~ "follows",
    TRUE ~ 'no'
)) %>% mutate(n = n()) %>% group_by(follows) %>% summarise(count = n() / nrow(.) ) #79.4% follows (SAME)

follow_braak_cs %>% filter(braak5_suvr == 1) %>% mutate(follows = case_when(
    braak4_suvr == 1 & braak3_suvr == 1 & braak1_suvr == 1 ~ "follows",
    TRUE ~ 'no'
)) %>% mutate(n = n()) %>% group_by(follows) %>% summarise(count = n() / nrow(.) ) #84.4% follows (Drop, but same)

follow_braak_cs %>% filter(braak4_suvr == 1) %>% mutate(follows = case_when(
    braak3_suvr == 1 & braak1_suvr == 1 ~ "follows",
    TRUE ~ 'no'
)) %>% mutate(n = n()) %>% group_by(follows) %>% summarise(count = n() / nrow(.) ) #93.2% follows (Same)

follow_braak_cs %>% filter(braak3_suvr == 1) %>% mutate(follows = case_when(
    braak1_suvr == 1 ~ "follows",
    TRUE ~ 'no'
)) %>% mutate(n = n()) %>% group_by(follows) %>% summarise(count = n() / nrow(.) ) #95% follows (Same)

```


```{r}
#Create the heatmap for AB+ participants
heat_map_braak_ab_pos_cuneg <- mask_braak_se_cuneg_bl %>%
  mutate(RID = fct_inorder(as.factor(RID))) %>% #Order the RIDs
  filter(AB_POSITIVITY_WCR == "AB+") %>% #Keep only AB+ participants
  ggplot(aes(y=RID, x=regions, fill=as.factor(spex))) +
  geom_tile() + #A heatmap can be plotted with geom_tile()
  theme_classic() + #Remove the axis in the back of the plot
  scale_fill_manual(values = c("#024F6D", "#FDE725"), labels=c("Negative", "Positive"), name="Regional positivity\nstatus") + #Turn negativity/positivity to Navy and Yellow
    #Each of the lines below require manual adjustments. If the number of participants change, you will need to change the numbers for the figure to be looking ok.
    #The only coordinates you should need to change is the y and yend
  annotate("segment", x=0.15, xend=0.15, y=1, yend=77, color="#ed1b2f") + #This will make a line to the left of the graph to designate AD participants
  annotate("Text", x=-0.2, y=35, angle=90, label='AD A\U03B2+', color="#ed1b2f") + #This will label the line for AD participants
  annotate("segment", x=0.15, xend=0.15, y=78, yend=209, color="#F7941D") +
  annotate("Text", x=-0.2, y=143, angle=90, label='MCI A\U03B2+', color="#F7941D") +
  annotate("segment", x=0.15, xend=0.15, y=210, yend=372, color="#44C8F5") +
  annotate("Text", x=-0.2, y=280, angle=90, label='CU A\U03B2+', color="#44C8F5") +
    #Label the Braak stages properly
  scale_x_discrete(labels=c("I", "III", "IV", "V", "VI")) +
  ylab("Participants \n(by diagnosis)") +
  xlab("Regions") +
  coord_cartesian(clip="off") + #This is to make sure the writings for each group are not cutoff by ggplot on the left side
  theme(axis.text.y = element_blank(), #Remove axis test for Y (we don't need the individual RIDs)
        axis.ticks.y = element_blank(), #Remove the ticks for Y (we don't need to know that each line is an RID, we can see that from the graph)
        line = element_blank(), #Remove the lines in the graph
        axis.title.y = element_text(vjust=2.5, face="bold", size=14), #Changes the title of the Y axis
        text = element_text(family="sans"), #Imposes font family and size
        axis.title.x = element_text(face="bold", size=14),
        axis.text.x = element_text(size = 12),
        legend.position = "none") #Removes the legend (we will have it on the cortical heatmap)

#Repeat the same steps for the cortical regions, with only a few differences
heat_map_ab_pos_cuneg <- mask_regional_se_cuneg_bl %>%
  mutate(RID = fct_inorder(as.factor(RID))) %>%
  filter(AB_POSITIVITY_WCR == "AB+") %>%
  ggplot(aes(y=RID, x=regions, fill=as.factor(spex))) +
  geom_tile() +
  theme_classic() +
  scale_fill_manual(values = c("#024F6D", "#FDE725"), labels=c("Negative", "Positive"), name="Regional positivity\nstatus") +
  annotate("segment", x=0.15, xend=0.15, y=1, yend=77, color="#ed1b2f") +
  annotate("Text", x=-0.5, y=35, angle=90, label='AD A\U03B2+', color="#ed1b2f", size=4) +
  annotate("segment", x=0.15, xend=0.15, y=78, yend=209, color="#F7941D") +
  annotate("Text", x=-0.5, y=143, angle=90, label='MCI A\U03B2+', color="#F7941D", size=4) +
  annotate("segment", x=0.15, xend=0.15, y=210, yend=372, color="#44C8F5") +
  annotate("Text", x=-0.5, y=280, angle=90, label='CU A\U03B2+', color="#44C8F5", size=4) +
    #We want a line separating each of the Braak stages
  geom_vline(xintercept = 2.5, color="black") +
  geom_vline(xintercept = 10.5, color="black") +
  geom_vline(xintercept = 26.5, color="black") +
  geom_vline(xintercept = 58.5, color="black") +
  geom_vline(xintercept = 42.5, color="black", linetype="dashed") + #This one is dashed because we split Braak V
                                                                    # arbitrarily between Frontal regions and the rest
  #Label each section with the right Braak stage
  annotate("text", x=1.5, y=-3, label="I", size=4) +
  annotate("text", x=6, y=-3, label="III", size=4) +
  annotate("text", x=18, y=-3, label="IV", size=4) +
  annotate("text", x=34, y=-3, label="V - Parietal", size=4) +
  annotate("text", x=50, y=-3, label="V - Frontal", size=4) +
  annotate("text", x=64, y=-3, label="VI", size=4) +
  coord_cartesian(clip="off") +
  xlab("Regions") +
  theme(axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.ticks.x = element_blank(),
        line = element_blank(),
        axis.title.y = element_blank(),
        axis.title.x = element_text(vjust=-0.2, face="bold", size=14),
        legend.text = element_text(size=12),
        legend.title = element_text(size=14))

patch_heatmap_ab_pos_cuneg <- heat_map_braak_ab_pos_cuneg + heat_map_ab_pos_cuneg + plot_layout(widths = c(1.5, 12)) #Fit the Braak and cortical graphs together in one plot

ggsave(glue("{figure_space}/suppfigure11_raw.png"), plot=patch_heatmap_ab_pos_cuneg, width = 14.5, height = 8, units="in", dpi=500) #Output
#Note: if you change anything about the size of the graph (e.g., nb of participants) you will need to play with the dimensions here

```

##### Supp Figure 12

This one replicates the cognition analysis but using the spatial extent from CU AB-

```{r}
final_data_cog_ab_pos <- final_data %>%
    filter(AB_POSITIVITY_WCR == 1) %>%
    mutate(DIAGNOSIS = case_when(DIAGNOSIS == 1 ~ 'CU',
                                 DIAGNOSIS == 2 ~ 'MCI',
                                 DIAGNOSIS == 3 ~ 'AD'))

#We scale to each cognitive measure specifically to better see the effect.
min(final_data_cog_ab_pos$ADNI_MEM, na.rm=TRUE) #-2.487
max(final_data_cog_ab_pos$ADNI_MEM, na.rm=TRUE) #3.358
min(final_data_cog_ab_pos$ADNI_EF, na.rm=TRUE) #-2.788
max(final_data_cog_ab_pos$ADNI_EF, na.rm=TRUE) #2.994
min(final_data_cog_ab_pos$ADNI_LAN, na.rm=TRUE) #-1.602
max(final_data_cog_ab_pos$ADNI_LAN, na.rm=TRUE) #2.406
min(final_data_cog_ab_pos$ADNI_VSP, na.rm=TRUE) #-1.89
max(final_data_cog_ab_pos$ADNI_VSP, na.rm=TRUE) #0.483


cog_spex_cuneg_mem_bl <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_2sd_cu_ab_neg", outcome="ADNI_MEM",
                        x_lab_val="Spatial Extent Index (CU A\U03B2-)", lim_x_vals = c(0, 70), y_lab_val = "Memory composite score", lim_y_vals = c(-2.5, 3.4),
                        lm_diagnostics = FALSE)
cog_spex_cuneg_ef_bl <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_2sd_cu_ab_neg", outcome="ADNI_EF",
                        x_lab_val="Spatial Extent Index (CU A\U03B2-)", lim_x_vals = c(0, 70), y_lab_val = "Executive composite score", lim_y_vals = c(-2.8, 3),
                        lm_diagnostics = FALSE)
cog_spex_cuneg_lan_bl <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_2sd_cu_ab_neg", outcome="ADNI_LAN",
                        x_lab_val="Spatial Extent Index (CU A\U03B2-)", lim_x_vals = c(0, 70), y_lab_val = "Language composite score", lim_y_vals = c(-1.6, 2.5),
                        lm_diagnostics = FALSE)
cog_spex_cuneg_vsp_bl <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_2sd_cu_ab_neg", outcome="ADNI_VSP",
                        x_lab_val="Spatial Extent Index (CU A\U03B2-)", lim_x_vals = c(0, 70), y_lab_val = "Visuospatial composite score", lim_y_vals = c(-1.9, 0.5),
                        lm_diagnostics = FALSE)


patch_cog_cuneg <- (cog_spex_cuneg_mem_bl / cog_spex_cuneg_ef_bl / cog_spex_cuneg_lan_bl / cog_spex_cuneg_vsp_bl)


ggsave(glue("{figure_space}/suppfigure12_raw.png"), plot=patch_cog_cuneg, width=12, height=12, dpi=500)
```

##### Supp Figure 13

```{r}
final_data_cog_ab_pos <- final_data %>%
    filter(AB_POSITIVITY_WCR == 1) %>%
    mutate(DIAGNOSIS = case_when(DIAGNOSIS == 1 ~ 'CU',
                                 DIAGNOSIS == 2 ~ 'MCI',
                                 DIAGNOSIS == 3 ~ 'AD'))

min(final_data_cog_ab_pos$annual_slope_adnimem, na.rm=TRUE) #-0.43
max(final_data_cog_ab_pos$annual_slope_adnimem, na.rm=TRUE) #0.159
min(final_data_cog_ab_pos$annual_slope_adnief, na.rm=TRUE) #-0.357
max(final_data_cog_ab_pos$annual_slope_adnief, na.rm=TRUE) #0.076
min(final_data_cog_ab_pos$annual_slope_adnilan, na.rm=TRUE) #-0.21
max(final_data_cog_ab_pos$annual_slope_adnilan, na.rm=TRUE) #0.067
min(final_data_cog_ab_pos$annual_slope_adnivsp, na.rm=TRUE) #-0.179
max(final_data_cog_ab_pos$annual_slope_adnivsp, na.rm=TRUE) #0.060

cog_spex_cuneg_mem_long <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_2sd_cu_ab_neg", outcome="annual_slope_adnimem",
                        x_lab_val="Spatial Extent Index (CU A\U03B2-)", lim_x_vals = c(0, 70), y_lab_val = "Memory composite score decline", lim_y_vals = c(-0.45, 0.16),
                        lm_diagnostics = FALSE)
cog_spex_cuneg_ef_long <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_2sd_cu_ab_neg", outcome="annual_slope_adnief",
                        x_lab_val="Spatial Extent Index (CU A\U03B2-)", lim_x_vals = c(0, 70), y_lab_val = "Executive composite score decline", lim_y_vals = c(-0.4, 0.08),
                        lm_diagnostics = FALSE)
cog_spex_cuneg_lan_long <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_2sd_cu_ab_neg", outcome="annual_slope_adnilan",
                        x_lab_val="Spatial Extent Index (CU A\U03B2-)", lim_x_vals = c(0, 70), y_lab_val = "Language composite score decline", lim_y_vals = c(-0.22, 0.07),
                        lm_diagnostics = FALSE)
cog_spex_cuneg_vsp_long <- biom_comp(final_data_cog_ab_pos, bio="spatial_extent_thresh_2sd_cu_ab_neg", outcome="annual_slope_adnivsp",
                        x_lab_val="Spatial Extent Index (CU A\U03B2-)", lim_x_vals = c(0, 70), y_lab_val = "Visuospatial composite score decline", lim_y_vals = c(-0.18, 0.06),
                        lm_diagnostics = FALSE)


patch_cog_cuneg_long <- (cog_spex_cuneg_mem_long / cog_spex_cuneg_ef_long / cog_spex_cuneg_lan_long / cog_spex_cuneg_vsp_long)


ggsave(glue("{figure_space}/suppfigure13_raw.png"), plot=patch_cog_cuneg_long, width=12, height=12, dpi=500)
```

Here, add the Vuong tests between the meta and the CU AB- (only the ones different with the GMM)

```{r}
vuongtest(
    lm(ADNI_LAN ~ meta_roi_tau_jack_tau + PTGENDER + PTAGE + PTEDUCAT, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")),
    lm(ADNI_LAN ~ spatial_extent_thresh_2sd_cu_ab_neg + PTGENDER + PTAGE + PTEDUCAT, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")) # No difference
)

vuongtest(
    lm(ADNI_EF ~ meta_roi_tau_jack_tau + PTGENDER + PTAGE + PTEDUCAT, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")),
    lm(ADNI_EF ~ spatial_extent_thresh_2sd_cu_ab_neg + PTGENDER + PTAGE + PTEDUCAT, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")) # No difference
)

vuongtest(
    lm(ADNI_EF ~ meta_roi_tau_jack_tau + PTGENDER + PTAGE + PTEDUCAT, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")),
    lm(ADNI_EF ~ spatial_extent_thresh_2sd_cu_ab_neg + PTGENDER + PTAGE + PTEDUCAT, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "AD")) # No difference, but trending.
)

vuongtest(
    lm(annual_slope_adnief ~ meta_roi_tau_jack_tau + PTGENDER + PTAGE + PTEDUCAT, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")),
    lm(annual_slope_adnief ~ spatial_extent_thresh_2sd_cu_ab_neg + PTGENDER + PTAGE + PTEDUCAT, data=final_data_cog_ab_pos %>% filter(DIAGNOSIS == "MCI")) # No difference
)

```


#### R2: C 2.7
The reviwer is suggesting a paper in which measures of asymmetry + divergent of MTL-first are used as heterogeneity.

For comparison, we can do the same method as the Young (2022) paper. We need all AB+, and then we will create the same metrics. We can start from the regional SUVR.

```{r}
# The format of the data cleaning is similar to the heatmaps, but we need to isolate the data from each diagnosis.
#Finding the variables on the participants that should be included in the analysis
ids_index <- final_data %>%
    select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5) %>% #Only keep variables we need
    #Transform the numbers to factors, which makes it easier to deal with when arranging them.
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(AB_POSITIVITY_WCR = as.factor(case_when(AB_POSITIVITY_WCR == 0 ~ "AB-",
                                         AB_POSITIVITY_WCR == 1 ~ "AB+")))

#Import SUVR mask
mask_map_regional_suvr <- read_csv(glue("{project_space}/suvr_values_long.csv")) 
mask_map_regional_suvr_bl <- mask_map_regional_suvr %>%
    filter(tau_pet_number == 1) %>% #Keep only baselines
    select(-c(EXAMDATE_tau, tau_pet_number)) %>% #Remove examdate and tau_pet_number (no longer useful)
    left_join(ids_index) %>% 
    filter(AB_POSITIVITY_WCR == "AB+") %>%
    select(-AB_POSITIVITY_WCR, -spatial_extent_thresh_0.5)
```

Next, they create meta-ROIs from a specific set of regions. We can recreate it here.

```{r}
rois_asymmetry <- mask_map_regional_suvr_bl %>%
    #Create the ROIs from Young 2022 paper
    mutate(roi_medial_temporal_lh = (CTX_LH_ENTORHINAL_SUVR +
                                  CTX_LH_PARAHIPPOCAMPAL_SUVR) / 2) %>%
    mutate(roi_medial_temporal_rh = (CTX_RH_ENTORHINAL_SUVR +
                                  CTX_RH_PARAHIPPOCAMPAL_SUVR) / 2) %>%
    mutate(roi_medial_temporal_bilat = (CTX_LH_ENTORHINAL_SUVR + CTX_RH_ENTORHINAL_SUVR +
                                  CTX_LH_PARAHIPPOCAMPAL_SUVR + CTX_RH_PARAHIPPOCAMPAL_SUVR) / 4) %>%
    
    mutate(roi_lateral_temporal_lh = (CTX_LH_SUPERIORTEMPORAL_SUVR +
                                  CTX_LH_MIDDLETEMPORAL_SUVR +
                                  CTX_LH_INFERIORTEMPORAL_SUVR) / 3) %>%
    mutate(roi_lateral_temporal_rh = (CTX_RH_SUPERIORTEMPORAL_SUVR +
                                  CTX_RH_MIDDLETEMPORAL_SUVR +
                                  CTX_RH_INFERIORTEMPORAL_SUVR) / 3) %>%
    mutate(roi_lateral_temporal_bilat = (CTX_LH_SUPERIORTEMPORAL_SUVR + CTX_RH_SUPERIORTEMPORAL_SUVR +
                                  CTX_LH_MIDDLETEMPORAL_SUVR + CTX_RH_MIDDLETEMPORAL_SUVR +
                                  CTX_LH_INFERIORTEMPORAL_SUVR + CTX_RH_INFERIORTEMPORAL_SUVR) / 6) %>%
    
    mutate(roi_medial_parietal_lh = (CTX_LH_POSTERIORCINGULATE_SUVR +
                                 CTX_LH_PRECUNEUS_SUVR ) / 2) %>%
    mutate(roi_medial_parietal_rh = (CTX_RH_POSTERIORCINGULATE_SUVR +
                                 CTX_RH_PRECUNEUS_SUVR) / 2) %>%
    mutate(roi_medial_parietal_bilat = (CTX_LH_POSTERIORCINGULATE_SUVR + CTX_RH_POSTERIORCINGULATE_SUVR +
                                 CTX_LH_PRECUNEUS_SUVR + CTX_RH_PRECUNEUS_SUVR) / 4) %>%
    
    mutate(roi_lateral_parietal_lh = (CTX_LH_INFERIORPARIETAL_SUVR +
                                 CTX_LH_SUPERIORPARIETAL_SUVR +
                                 CTX_LH_SUPRAMARGINAL_SUVR) / 3) %>%
    mutate(roi_lateral_parietal_rh = (CTX_RH_INFERIORPARIETAL_SUVR +
                                 CTX_RH_SUPERIORPARIETAL_SUVR +
                                 CTX_RH_SUPRAMARGINAL_SUVR) / 3) %>%
    mutate(roi_lateral_parietal_bilat = (CTX_LH_INFERIORPARIETAL_SUVR + CTX_RH_INFERIORPARIETAL_SUVR +
                                 CTX_LH_SUPERIORPARIETAL_SUVR + CTX_RH_SUPERIORPARIETAL_SUVR +
                                 CTX_LH_SUPRAMARGINAL_SUVR + CTX_RH_SUPRAMARGINAL_SUVR) / 6) %>%

    mutate(roi_frontal_lh = (CTX_LH_SUPERIORFRONTAL_SUVR +
                        CTX_LH_ROSTRALMIDDLEFRONTAL_SUVR +
                        CTX_LH_CAUDALMIDDLEFRONTAL_SUVR +
                        CTX_LH_LATERALORBITOFRONTAL_SUVR +
                        CTX_LH_MEDIALORBITOFRONTAL_SUVR) / 5) %>%
    mutate(roi_frontal_rh = (CTX_RH_SUPERIORFRONTAL_SUVR +
                        CTX_RH_ROSTRALMIDDLEFRONTAL_SUVR +
                        CTX_RH_CAUDALMIDDLEFRONTAL_SUVR +
                        CTX_RH_LATERALORBITOFRONTAL_SUVR +
                        CTX_RH_MEDIALORBITOFRONTAL_SUVR) / 5) %>%
    mutate(roi_frontal_bilat = (CTX_LH_SUPERIORFRONTAL_SUVR + CTX_RH_SUPERIORFRONTAL_SUVR +
                        CTX_LH_ROSTRALMIDDLEFRONTAL_SUVR + CTX_RH_ROSTRALMIDDLEFRONTAL_SUVR +
                        CTX_LH_CAUDALMIDDLEFRONTAL_SUVR + CTX_RH_CAUDALMIDDLEFRONTAL_SUVR +
                        CTX_LH_LATERALORBITOFRONTAL_SUVR + CTX_RH_LATERALORBITOFRONTAL_SUVR +
                        CTX_LH_MEDIALORBITOFRONTAL_SUVR + CTX_RH_MEDIALORBITOFRONTAL_SUVR) / 10) %>%
    
    mutate(roi_occipital_lh = (CTX_LH_PERICALCARINE_SUVR +
                        CTX_LH_CUNEUS_SUVR +
                        CTX_LH_LATERALOCCIPITAL_SUVR) / 3) %>%
    mutate(roi_occipital_rh = (CTX_RH_PERICALCARINE_SUVR +
                        CTX_RH_CUNEUS_SUVR +
                        CTX_RH_LATERALOCCIPITAL_SUVR) / 3) %>%
    mutate(roi_occipital_bilat = (CTX_LH_PERICALCARINE_SUVR + CTX_RH_PERICALCARINE_SUVR +
                        CTX_LH_CUNEUS_SUVR + CTX_RH_CUNEUS_SUVR +
                        CTX_LH_LATERALOCCIPITAL_SUVR + CTX_RH_LATERALOCCIPITAL_SUVR) / 6) %>%
    #Create the measure of typicality (entorhinal over tau in more advanced regions)
    mutate(typicality = ((CTX_LH_ENTORHINAL_SUVR + CTX_RH_ENTORHINAL_SUVR) / 2) / 
               ((CTX_LH_CAUDALMIDDLEFRONTAL_SUVR + CTX_RH_CAUDALANTERIORCINGULATE_SUVR +
               CTX_LH_INFERIORPARIETAL_SUVR + CTX_RH_INFERIORPARIETAL_SUVR +
               CTX_LH_SUPERIORFRONTAL_SUVR + CTX_RH_SUPERIORFRONTAL_SUVR) / 6)) %>%
    
    select(-c(CTX_LH_BANKSSTS_SUVR:CTX_RH_AMYGDALA_SUVR)) #Remove the SUVR columns we don't need anymore
    
```

Next, we compute the two measures: the asymmetric index and the residuals

```{r}
#Finally, calculate the metrics used to determine heterogeneity (asymmetry and residuals)
final_asymmetric_data <- rois_asymmetry %>%
    #First is the asymetric index. The unit is percentage.
    mutate(assym_roi_medial_temporal = 200 * 
               ((roi_medial_temporal_rh - roi_medial_temporal_lh)/(roi_medial_temporal_rh + roi_medial_temporal_lh))) %>%
    mutate(assym_roi_lateral_temporal = 200 * 
               ((roi_lateral_temporal_rh - roi_lateral_temporal_lh)/(roi_lateral_temporal_rh + roi_lateral_temporal_lh))) %>%
    mutate(assym_roi_lateral_parietal = 200 * 
               ((roi_lateral_parietal_rh - roi_lateral_parietal_lh)/(roi_lateral_parietal_rh + roi_lateral_parietal_lh))) %>%
    mutate(assym_roi_medial_parietal = 200 * 
               ((roi_medial_parietal_rh - roi_medial_parietal_lh)/(roi_medial_parietal_rh + roi_medial_parietal_lh))) %>%
    mutate(assym_roi_frontal = 200 * 
               ((roi_frontal_rh - roi_frontal_lh)/(roi_frontal_rh + roi_frontal_lh))) %>%
    mutate(assym_roi_occipital = 200 * 
               ((roi_occipital_rh - roi_occipital_lh)/(roi_occipital_rh + roi_occipital_lh))) %>%
    #Next, we need to get the residuals from the models contrasting each bilateral to the MTL bilateral
    mutate(resid_lateral_temp = lm(roi_lateral_temporal_bilat ~ roi_medial_temporal_bilat, data=rois_asymmetry)$residuals) %>%
    mutate(resid_lateral_pariet = lm(roi_lateral_parietal_bilat ~ roi_medial_temporal_bilat, data=rois_asymmetry)$residuals) %>%
    mutate(resid_medial_pariet = lm(roi_medial_parietal_bilat ~ roi_medial_temporal_bilat, data=rois_asymmetry)$residuals) %>%
    mutate(resid_frontal = lm(roi_frontal_bilat ~ roi_medial_temporal_bilat, data=rois_asymmetry)$residuals) %>%
    mutate(resid_occipital = lm(roi_occipital_bilat ~ roi_medial_temporal_bilat, data=rois_asymmetry)$residuals) %>%
    #Finally, we just remove columns we no longer need (anything starting with roi)
    select(-starts_with('roi'))


```

The final measure in the paper is anyone 3SD away from the mean of A+ participants. Due to the nature of the analyses here, I probably want to do this separately for each diagnosis.

```{r}
asym_cu <- final_asymmetric_data %>% filter(DIAGNOSIS == "CU") %>%
    mutate(asym_group = case_when(
        #Asymetric when the participant is 3SD above the mean of asymetry
        assym_roi_medial_temporal > (mean(assym_roi_medial_temporal) + 3*sd(assym_roi_medial_temporal)) |
        assym_roi_lateral_temporal > (mean(assym_roi_lateral_temporal) + 3*sd(assym_roi_lateral_temporal)) |
        assym_roi_medial_parietal > (mean(assym_roi_medial_parietal) + 3*sd(assym_roi_medial_parietal)) |
        assym_roi_lateral_parietal > (mean(assym_roi_lateral_parietal) + 3*sd(assym_roi_lateral_parietal)) |
        assym_roi_frontal > (mean(assym_roi_frontal) + 3*sd(assym_roi_frontal)) |
        assym_roi_occipital > (mean(assym_roi_occipital) + 3*sd(assym_roi_occipital)) |
        resid_lateral_temp > (mean(resid_lateral_temp) + 3*sd(resid_lateral_temp)) |
        resid_medial_pariet > (mean(resid_medial_pariet) + 3*sd(resid_medial_pariet)) |
        resid_lateral_pariet > (mean(resid_lateral_pariet) + 3*sd(resid_lateral_pariet)) |
        resid_frontal > (mean(resid_frontal) + 3*sd(resid_frontal)) |
        resid_occipital > (mean(resid_occipital) + 3*sd(resid_occipital)) ~ 1,
        TRUE ~ 0
    ))

asym_mci <- final_asymmetric_data %>% filter(DIAGNOSIS == "MCI") %>%
    mutate(asym_group = case_when(
        assym_roi_medial_temporal > (mean(assym_roi_medial_temporal) + 3*sd(assym_roi_medial_temporal)) |
        assym_roi_lateral_temporal > (mean(assym_roi_lateral_temporal) + 3*sd(assym_roi_lateral_temporal)) |
        assym_roi_medial_parietal > (mean(assym_roi_medial_parietal) + 3*sd(assym_roi_medial_parietal)) |
        assym_roi_lateral_parietal > (mean(assym_roi_lateral_parietal) + 3*sd(assym_roi_lateral_parietal)) |
        assym_roi_frontal > (mean(assym_roi_frontal) + 3*sd(assym_roi_frontal)) |
        assym_roi_occipital > (mean(assym_roi_occipital) + 3*sd(assym_roi_occipital)) |
        resid_lateral_temp > (mean(resid_lateral_temp) + 3*sd(resid_lateral_temp)) |
        resid_medial_pariet > (mean(resid_medial_pariet) + 3*sd(resid_medial_pariet)) |
        resid_lateral_pariet > (mean(resid_lateral_pariet) + 3*sd(resid_lateral_pariet)) |
        resid_frontal > (mean(resid_frontal) + 3*sd(resid_frontal)) |
        resid_occipital > (mean(resid_occipital) + 3*sd(resid_occipital)) ~ 1,
        TRUE ~ 0
    ))

sum(asym_cu$asym_group) #35/172 5/172 / # 7/132 / #2/92 8 15 5

prop.test(x = c(8, 15), n = c(172, 132)) #Check if proportion differs

TukeyHSD(aov(resid_lateral_temp ~ DIAGNOSIS, data=final_asymmetric_data)) #MCI less than AD, MCI
final_asymmetric_data %>% group_by(DIAGNOSIS) %>% summarize(mean = mean(resid_lateral_temp))
TukeyHSD(aov(resid_medial_pariet ~ DIAGNOSIS, data=final_asymmetric_data)) #MCI less than AD, no diff with CU
TukeyHSD(aov(resid_lateral_pariet ~ DIAGNOSIS, data=final_asymmetric_data)) #MCI less than AD, no diff with CU
TukeyHSD(aov(resid_frontal ~ DIAGNOSIS, data=final_asymmetric_data)) #MCI less than AD, MCI less than CU
TukeyHSD(aov(resid_occipital ~ DIAGNOSIS, data=final_asymmetric_data)) #No difference


TukeyHSD(aov(typicality ~ DIAGNOSIS, data=final_asymmetric_data))
final_asymmetric_data %>% group_by(DIAGNOSIS) %>% summarize(mean = mean(typicality))
```

Overall, it doesn't seem like people are asymmetric or progress more outside in the MTL than outside. But MCI have more of the metric than CU. These are not added to the manuscript or supplementary figures.

#### R2: C. 2.9

Here, we check the linearity of the LMEs to estimate the cognitive trajectories.

```{r, fig.height=20, fig.width=20}
slope_adni_mem <- lmer(ADNI_MEM ~ cum_cog_years + (cum_cog_years | RID), data=cog_time_calc)
slope_adni_ef <- lmer(ADNI_EF ~ cum_cog_years + (cum_cog_years | RID), data=cog_time_calc)
slope_adni_lan <- lmer(ADNI_LAN ~ cum_cog_years + (cum_cog_years | RID), data=cog_time_calc)
slope_adni_vsp <- lmer(ADNI_VSP ~ cum_cog_years + (cum_cog_years | RID), data=cog_time_calc)

#Generate the assumption checks for the four domains
performance::check_model(slope_adni_mem) #Homoskedasticity looks broken. Verify the assumption below:
    performance::check_heteroscedasticity(slope_adni_mem) #Error variance is homoscedastic so ok
performance::check_model(slope_adni_ef) #Assumptions are ok
performance::check_model(slope_adni_lan) #Homoskedasticity looks broken. Verify below:
    performance::check_heteroskedasticity(slope_adni_lan) #Homoscedasticity is ok
performance::check_model(slope_adni_vsp) #Everything looks super weird
```

```{r}
cog_time_calc
```

Overall it looks like the assumptions don't hold for VSP. However, we will not fix it because it's likely due to the data underneath.


#### R2: C. 2.10

The reviewer is specifically asking about the floor and ceiling effects of the linear mixed models. For the brain templates of Figure 4C, this doesn't matter because we are using summed data (p. The only time we look at LMEs and spatial extent is for Supp Figure 3.

The reviewer is right: the spatial extent index is in effect more a "count" data (as we count the number of regions). Count data is best analyzed with Poisson distribution (i.e., GLM).

```{r}
#Create the dataframes used for the final LMER models for the spatial extent
spex_long <- spex_gmm_time_calc %>%
  select(RID, tau_pet_number, spatial_extent_thresh_0.5, cum_spex_gmm_years) %>%
  left_join(final_data %>% select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, PTAGE, PTGENDER, PTEDUCAT),
            by=c('RID')) %>%
  filter(AB_POSITIVITY_WCR == 1) %>%
  filter(tau_pet_number <= 3) %>%
  mutate(PTGENDER = as.factor(case_when(PTGENDER == 1 ~ "Male",
                              PTGENDER == 2 ~ "Female"))) %>%
  mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
  mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("MCI", "CU", "AD"))) #%>%
  #mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("MCI", "CU", "AD"))) #To compare a different order in the group LME, if needed
```

Here we run the models

```{r}
#First, let's model the data with LMEs (original figure)
lmer_spex_cu <- lmer(spatial_extent_thresh_0.5 ~ cum_spex_gmm_years + (cum_spex_gmm_years|RID), data=spex_long %>% filter(DIAGNOSIS == "CU"))
summary(lmer_spex_cu)
lmer_spex_mci <- lmer(spatial_extent_thresh_0.5 ~ cum_spex_gmm_years + (cum_spex_gmm_years|RID), data=spex_long %>% filter(DIAGNOSIS == "MCI"))
summary(lmer_spex_mci)
lmer_spex_ad <- lmer(spatial_extent_thresh_0.5 ~ cum_spex_gmm_years + (cum_spex_gmm_years|RID), data=spex_long %>% filter(DIAGNOSIS == "AD"))
summary(lmer_spex_ad)

#Next, we can plot the models with the poisson regression instead
lmer_spex_poi_cu <- glmer(spatial_extent_thresh_0.5 ~ cum_spex_gmm_years + (cum_spex_gmm_years|RID), data=spex_long %>% filter(DIAGNOSIS == "CU"), family=poisson())
summary(lmer_spex_poi_cu)
lmer_spex_poi_mci <- glmer(spatial_extent_thresh_0.5 ~ cum_spex_gmm_years + (cum_spex_gmm_years|RID), data=spex_long %>% filter(DIAGNOSIS == "MCI"), family=poisson())
summary(lmer_spex_poi_mci)
lmer_spex_poi_ad <- glmer(spatial_extent_thresh_0.5 ~ cum_spex_gmm_years + (cum_spex_gmm_years|RID), data=spex_long %>% filter(DIAGNOSIS == "AD"), family=poisson())
summary(lmer_spex_poi_ad)
glmer_interact_spex_diag <- glmer(spatial_extent_thresh_0.5 ~ cum_spex_gmm_years*DIAGNOSIS + (cum_spex_gmm_years|RID), data=spex_long %>% mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("MCI", "CU", "AD"))), family=poisson())
summary(glmer_interact_spex_diag)


#It is possible that poisson regression suffers from 0-inflation (i.e., incorrectly predicts 0s in the data)
performance::check_zeroinflation(lmer_spex_poi_cu) #Ok
performance::check_zeroinflation(lmer_spex_poi_mci) #Underfits zeros
performance::check_zeroinflation(lmer_spex_poi_ad) #Underfits zeros

#Since this is the case, we can instead use a zero-inflated poisson regression which will better account for the zero-inflation
summary(zeroinfl(spatial_extent_thresh_0.5 ~ cum_spex_gmm_years + cum_spex_gmm_years | RID, data=spex_long %>% filter(DIAGNOSIS == "CU")))
summary(zeroinfl(spatial_extent_thresh_0.5 ~ cum_spex_gmm_years + cum_spex_gmm_years | RID, data=spex_long %>% filter(DIAGNOSIS == "MCI")))
summary(zeroinfl(spatial_extent_thresh_0.5 ~ cum_spex_gmm_years + cum_spex_gmm_years | RID, data=spex_long %>% filter(DIAGNOSIS == "AD")))
summary(zeroinfl(spatial_extent_thresh_0.5 ~ cum_spex_gmm_years*DIAGNOSIS + cum_spex_gmm_years | RID, data=spex_long %>% mutate(DIAGNOSIS == fct_relevel(DIAGNOSIS, c("MCI", "CU", "AD")))))

#Results are similar to the LME
# We can replot Supp Figure 3 with the new estimates instead
# Estimates from a Poisson regression are in log(count). We can exponentiate them to get back to the region/year estimate
#### CU
exp(1.94267) #6.977 --- Intercept
exp(0.24409) #1.276 --- Beta
             #0.03246 --- Std Error

#### MCI
exp(2.75724) #15.7563 --- Intercept
exp(0.19028) #1.20958 --- Beta
             #0.02085 --- Std Error

#### 
exp(3.40235) #30.0346 --- Intercept
exp(-0.01224) #0.9878346 --- Beta
             #0.02413 --- Std Error

```

Redo the entire figure here, but substitute the numbers for the spatial extent plot

```{r}
#Create the dataframe used for the final LMER models for meta_roi
meta_roi_long <- meta_roi_time_calc %>%
  select(RID, tau_pet_number, meta_roi_tau_jack_tau, cum_meta_roi_years) %>%
  left_join(final_data %>% select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, PTAGE, PTGENDER, PTEDUCAT),
            by=c('RID')) %>%
  filter(AB_POSITIVITY_WCR == 1) %>%
  filter(tau_pet_number <= 3) %>%
  mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
  mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("CU", "MCI", "AD"))) #%>%
  #mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("MCI", "CU", "AD"))) #To compare a different order in the group LME, if needed

#Create the dataframes used for the final LMER models for the spatial extent
spex_long <- spex_gmm_time_calc %>%
  select(RID, tau_pet_number, spatial_extent_thresh_0.5, cum_spex_gmm_years) %>%
  left_join(final_data %>% select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, PTAGE, PTGENDER, PTEDUCAT),
            by=c('RID')) %>%
  filter(AB_POSITIVITY_WCR == 1) %>%
  filter(tau_pet_number <= 3) %>%
  mutate(PTGENDER = as.factor(case_when(PTGENDER == 1 ~ "Male",
                              PTGENDER == 2 ~ "Female"))) %>%
  mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
  mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("CU", "MCI", "AD"))) #%>%
  #mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("MCI", "CU", "AD"))) #To compare a different order in the group LME, if needed

#run the model for each measure of tau, for each 
lmer_meta_cu <- lmer_tau(meta_roi_long, diag="CU", outcome = "meta_roi_tau_jack_tau", time = "cum_meta_roi_years", covar="PTGENDER + PTAGE + PTEDUCAT")
lmer_meta_mci <- lmer_tau(meta_roi_long, diag="MCI", outcome = "meta_roi_tau_jack_tau", time = "cum_meta_roi_years", covar="PTGENDER + PTAGE + PTEDUCAT")
lmer_meta_ad <- lmer_tau(meta_roi_long, diag="AD", outcome = "meta_roi_tau_jack_tau", time = "cum_meta_roi_years", covar="PTGENDER + PTAGE + PTEDUCAT")
```

```{r}
ggplot_meta_roi_jack_long <- meta_roi_long %>%
  ggplot(aes(x=cum_meta_roi_years, y=meta_roi_tau_jack_tau)) +
  geom_point(aes(color=as.factor(DIAGNOSIS)), alpha=0.7) +
  geom_line(aes(group=RID, color=as.factor(DIAGNOSIS)), alpha=0.1) +
  annotate("segment", x=min(meta_roi_long$cum_meta_roi_years), #The start of the segment is the minimum years in the data (so 0)
           xend=max(meta_roi_long$cum_meta_roi_years), #The end is the maximum years in the data 
           #Next, we draw the segment. The y is the start (i.e, intercept).
           #The end of the y is equal to the intercept (when slope is 0) + the slope (tau per year) multiplied by the maximum number of years
           y=lmer_meta_cu[[1,2]], yend=lmer_meta_cu[[1,2]] + lmer_meta_cu[[1,3]]*max(meta_roi_long$cum_meta_roi_years), 
           size=0.50, color="#44C8F5") +
            #The ribbon is a representation of the error in representing the slope. It's not particularly visible in most cases, so we multiply
            #the error by 3 to make it visible.
            #Geom ribbon only takes one X, which should be the time of each participant.
            #Then, for the y, we make it follow the slope, so we need to copy the same code, but with the twist that we multiply the slope by
            #the error
  geom_ribbon(aes(x=cum_meta_roi_years, 
                  ymin=cum_meta_roi_years*lmer_meta_cu[[1,3]] + lmer_meta_cu[[1,2]] - (lmer_meta_cu[[1,4]]*3),
                  ymax=cum_meta_roi_years*lmer_meta_cu[[1,3]] + lmer_meta_cu[[1,2]] + (lmer_meta_cu[[1,4]]*3)), 
              fill="#44C8F5", alpha=0.3) +
  
  annotate("segment", x=min(meta_roi_long$cum_meta_roi_years), #This segment is the slope of MCI
           xend=max(meta_roi_long$cum_meta_roi_years),
           y=lmer_meta_mci[[1,2]], yend=lmer_meta_mci[[1,2]] + lmer_meta_mci[[1,3]]*max(meta_roi_long$cum_meta_roi_years), 
           size=0.50, color="#F7941D") +
  geom_ribbon(aes(x=cum_meta_roi_years, 
                  ymin=cum_meta_roi_years*lmer_meta_mci[[1,3]] + lmer_meta_mci[[1,2]] - (lmer_meta_mci[[1,4]]*3),
                  ymax=cum_meta_roi_years*lmer_meta_mci[[1,3]] + lmer_meta_mci[[1,2]] + (lmer_meta_mci[[1,4]]*3)), 
              fill="#F7941D", alpha=0.3) +
  
  annotate("segment", x=min(meta_roi_long$cum_meta_roi_years), #This segment is the slope of AD
           xend=max(meta_roi_long$cum_meta_roi_years),
           y=lmer_meta_ad[1,2][[1]], yend=lmer_meta_ad[[1,2]] + lmer_meta_ad[[1,3]]*max(meta_roi_long$cum_meta_roi_years),
           size=0.50, color="#ED1B2F") +
  geom_ribbon(aes(x=cum_meta_roi_years, 
                  ymin=cum_meta_roi_years*lmer_meta_ad[[1,3]] + lmer_meta_ad[[1,2]] - (lmer_meta_ad[[1,4]]*3),
                  ymax=cum_meta_roi_years*lmer_meta_ad[[1,3]] + lmer_meta_ad[[1,2]] + (lmer_meta_ad[[1,4]]*3)),
              fill="#ED1B2F", alpha=0.3) +
  
  annotate("text", y=Inf, x =Inf, hjust=1, vjust=1.3,  
           label=glue("\U03B2 CU = {round(lmer_meta_cu[1,3][[1]], 3)} SUVR/year ***
                      \U03B2 MCI = {round(lmer_meta_mci[1,3][[1]], 3)} SUVR/year ***
                      \U03B2 AD = {round(lmer_meta_ad[1,3][[1]], 3)} SUVR/year   ")) +
#\n\U03B2std CU = 0.132\n\U03B2std MCI = 0.144\n\U03B2std AD = 0.075
  scale_color_manual(values = c("#44C8F5", "#F7941D", "#ED1B2F"), labels=c("CU", "MCI", "AD"), name="Diagnostic\nstatus") +
  xlab("Time since baseline tau scan (years)") +
  ylab("Temporal meta-ROI SUVR") + 
  theme_classic() +
  theme(panel.grid.major = element_line(), #Reimports the axis grid (1/2)
          panel.grid.minor = element_line(), #Reimports the axis gris (1/2)
          text = element_text(size=14, family="sans"), #Imposes font family and size
          axis.title.x = element_text(face="bold"), #Bolds the axis title
          axis.title.y = element_text(face="bold"),
          plot.title = element_text(face='bold', hjust=0.5))

#ggplot_meta_roi_jack_long
#Same plot for spatial extent
ggplot_spex_long <- spex_long %>%
  ggplot(aes(x=cum_spex_gmm_years, y=spatial_extent_thresh_0.5)) +
  geom_point(aes(color=as.factor(DIAGNOSIS)), alpha=0.7) +
  geom_line(aes(group=RID, color=as.factor(DIAGNOSIS)), alpha=0.1) +
  annotate("segment", x=min(spex_long$cum_spex_gmm_years), #The start of the segment is the minimum years in the data (so 0)
           xend=max(spex_long$cum_spex_gmm_years), #The end is the maximum years in the data 
           #Next, we draw the segment. The y is the start (i.e, intercept).
           #The end of the y is equal to the intercept (when x is 0) + the slope (tau per year) multiplied by the maximum number of years
           y=6.977, yend=6.977 + 1.276*max(spex_long$cum_spex_gmm_years), 
           size=0.50, color="#44C8F5") +
            #The ribbon is a representation of the error in representing the slope. It's not particularly visible in most cases, so we multiply
            #the error by 3 to make it visible.
            #Geom ribbon only takes one X, which should be the time of each participant.
            #Then, for the y, we make it follow the slope, so we need to copy the same code, but with the twist that we multiply the slope by
            #the error
  geom_ribbon(aes(x=cum_spex_gmm_years, 
                  ymin=cum_spex_gmm_years*1.276 + 6.977 - (0.032*3),
                  ymax=cum_spex_gmm_years*1.276 + 6.977 + (0.032*3)), 
              fill="#44C8F5", alpha=0.3) +
  
  annotate("segment", x=min(spex_long$cum_spex_gmm_years), #This segment is the slope of MCI
           xend=max(spex_long$cum_spex_gmm_years),
           y=15.756, yend=15.756 + 1.210*max(spex_long$cum_spex_gmm_years), 
           size=0.50, color="#F7941D") +
  geom_ribbon(aes(x=cum_spex_gmm_years, 
                  ymin=cum_spex_gmm_years*1.210 + 15.756 - (0.021*3),
                  ymax=cum_spex_gmm_years*1.210 + 15.756 + (0.021*3)), 
              fill="#F7941D", alpha=0.3) +
  
  annotate("segment", x=min(spex_long$cum_spex_gmm_years), #This segment is the slope of AD
           xend=max(spex_long$cum_spex_gmm_years),
           y=30.034, yend=30.034 + 0.988*max(spex_long$cum_spex_gmm_years),
           size=0.50, color="#ED1B2F") +
  geom_ribbon(aes(x=cum_spex_gmm_years, 
                  ymin=cum_spex_gmm_years*0.988 + 30.034 - (0.024*3),
                  ymax=cum_spex_gmm_years*0.988 + 30.034 + (0.024*3)),
              fill="#ED1B2F", alpha=0.3) +
  
  annotate("text", y=Inf, x =Inf, hjust=1, vjust=1.3,  
           label=glue("\U03B2 CU = 1.276 regions/year ***
                      \U03B2 MCI = 1.210 regions/year ***
                      \U03B2 AD = 0.988 regions/year   ")) +
#\n\U03B2std CU = 0.132\n\U03B2std MCI = 0.144\n\U03B2std AD = 0.075
  scale_color_manual(values = c("#44C8F5", "#F7941D", "#ED1B2F"), labels=c("CU", "MCI", "AD"), name="Diagnostic\nstatus") +
  xlab("Time since baseline tau scan (years)") +
  ylab("Spatial extent index") +
  theme_classic() +
  theme(panel.grid.major = element_line(), #Reimports the axis grid (1/2)
          panel.grid.minor = element_line(), #Reimports the axis gris (1/2)
          text = element_text(size=14, family="sans"), #Imposes font family and size
          axis.title.x = element_text(face="bold"), #Bolds the axis title
          axis.title.y = element_text(face="bold"),
          plot.title = element_text(face="bold", hjust=0.5))

#ggplot_spex_long

```

```{r}
#Patch and tag the plots, and output

patch_lme_tau <- ggplot_meta_roi_jack_long + ggplot_spex_long + plot_layout(guides = "collect") + plot_annotation(tag_levels = 'A') &
    theme(plot.tag = element_text(face = 'bold', size=18))

ggsave(glue("{figure_space}/suppfigure3_raw.png"), plot=patch_lme_tau, width = 11.1, height=5, units="in", dpi=500)
```

#### R2: C. 2.12

The linearity assumption in a logistic regression applied to the log-odds of the dependant variable and the independant predictor.

```{r}
#Isolate the data needed for this analysis
log_regress_spex_ab <- final_data %>%
    mutate(se_status = case_when(spatial_extent_thresh_0.5 > 0 ~ 1,
                                 TRUE ~ 0)) %>%
    select(AB_POSITIVITY_WCR, se_status, DIAGNOSIS, centiloid) %>%
    mutate(centiloid_mod = centiloid + 40)

#Do the logistic regression
glm_bin_spex_ab <- glm(se_status ~ centiloid, data=log_regress_spex_ab, family="binomial")

#Extract the log-odds from the model
logodds <- glm_bin_spex_ab$linear.predictors #Extract log-odds. Same as doing: log(glm_bin_spex_ab$fitted.values/(1 - glm_bin_spex_ab$fitted.values))

#Plot the Centiloid values against the log-odds
plot_log_odds_pred <- ggplot() +
    geom_point(aes(x=log_regress_spex_ab$centiloid, y=logodds)) +
    xlab("Centiloid values") +
    ylab("Log-odds of spatial extent probability") +
    theme_classic() +
      theme(panel.grid.major = element_line(), #Reimports the axis grid (1/2)
          panel.grid.minor = element_line(), #Reimports the axis gris (1/2)
          #text = element_text(size=10, family="sans"), #Imposes font family and size
          text = element_text(family="sans"), #Imposes font family and size
          axis.title.x = element_text(face="bold"), #Bolds the axis title
          axis.title.y = element_text(face="bold"),
          aspect.ratio = 1) #Ensures a square is outputted

plot_log_odds_pred

ggsave(glue("{figure_space}/_suppfigure_X1.png"), plot=plot_log_odds_pred, width = 4, height=4, units='in', dpi=500)

```


#### R2: C. 2.14

R2 would like to see the CU map, but without the scaling of everyone.

##### Supp Figure 14

```{r}
# The format of the data cleaning is similar to the heatmaps, but we need to isolate the data from each diagnosis.
#Finding the variables on the participants that should be included in the analysis
ids_index <- final_data %>%
    select(RID, DIAGNOSIS, AB_POSITIVITY_WCR, spatial_extent_thresh_0.5) %>% #Only keep variables we need
    #Transform the numbers to factors, which makes it easier to deal with when arranging them.
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(AB_POSITIVITY_WCR = as.factor(case_when(AB_POSITIVITY_WCR == 0 ~ "AB-",
                                         AB_POSITIVITY_WCR == 1 ~ "AB+")))
```

```{r}
#Import binary masks 
mask_map_regional_se_gmm <- read_csv(glue("{project_space}/long_spex_gmm_mask.csv")) 
mask_map_regional_se_gmm_bl<- mask_map_regional_se_gmm %>%
    filter(tau_pet_number == 1) %>% #Keep only baselines
    select(-c(EXAMDATE_tau, tau_pet_number)) %>% #Remove examdate and tau_pet_number (no longer useful)
    left_join(ids_index) %>% 
    filter(AB_POSITIVITY_WCR == "AB+") %>%
    select(-RID, -AB_POSITIVITY_WCR, -spatial_extent_thresh_0.5)

#Compute the sums for each diagnostic group

spex_roi_cu <- roi_summarize_bl(data=mask_map_regional_se_gmm_bl, DIAG="CU", SIZE=163)

min(spex_roi_cu$brain_val) #To figure out the limits of the plot, we need the minimum % 
max(spex_roi_cu$brain_val) #To figure out the limits of the plot, we ned the maximum %
#Note: depending on the positivity, we might need to check all groups to ensure we got it right.


ggseg_spex_cu_bl <- brain_template_plotting(spex_roi_cu, c(0,18), legend_name="% of positive\n participants", plot_name="Cognitively\nUnimpaired A\U03B2+")


ggsave(glue("{figure_space}/suppfigure14_raw.png", plot=ggseg_spex_cu_bl), width = 5, height = 6, dpi=500)
```

#### R2: C 2.15

R2 would like to see the correlation between temporal meta-ROI and spatial extent index.

##### Supp Figure 15

In this figure, we want the correlation between meta-ROI SUVR and spatial extent index. The first step is to get the betas we will plot on our graphs.

```{r}
#Isolate the data needed
plot_meta_spex_data <- final_data %>%
    filter(AB_POSITIVITY_WCR == 1) %>%
    select(DIAGNOSIS, meta_roi_tau_jack_tau, spatial_extent_thresh_0.5)

plot_meta_spex_data_cu <- plot_meta_spex_data %>%
    filter(DIAGNOSIS == 1)

plot_meta_spex_data_mci <- plot_meta_spex_data %>%
    filter(DIAGNOSIS == 2)

plot_meta_spex_data_ad <- plot_meta_spex_data %>%
    filter(DIAGNOSIS == 3)


#Correlations (we'll just do regressions to match the plot)
summary(lm(spatial_extent_thresh_0.5 ~ meta_roi_tau_jack_tau, data=plot_meta_spex_data_cu))
summary(lm(spatial_extent_thresh_0.5 ~ meta_roi_tau_jack_tau, data=plot_meta_spex_data_mci))
summary(lm(spatial_extent_thresh_0.5 ~ meta_roi_tau_jack_tau, data=plot_meta_spex_data_ad))
```

Next, move to the plot

```{r}
#Arrange the data for the plot
plot_meta_spex_data <- final_data %>%
    filter(AB_POSITIVITY_WCR == 1) %>% #Keep only AB+
    select(DIAGNOSIS, meta_roi_tau_jack_tau, spatial_extent_thresh_0.5) %>% #Keep only these variables
    #Convert the numbers to labels for easier use
    mutate(DIAGNOSIS = as.factor(case_when(DIAGNOSIS == 1 ~ "CU",
                               DIAGNOSIS == 2 ~ "MCI",
                               DIAGNOSIS == 3 ~ "AD"))) %>%
    mutate(DIAGNOSIS = fct_relevel(DIAGNOSIS, c("CU", "MCI", "AD")))
    
#Create the plot
plot_meta_spex <- plot_meta_spex_data %>%
    #We fill and color with diagnosis so we can use the alpha on the points
    ggplot(aes(x = meta_roi_tau_jack_tau, y = spatial_extent_thresh_0.5, fill=as.factor(DIAGNOSIS), color=as.factor(DIAGNOSIS))) +
    stat_smooth(formula = "y ~ x", method='lm', fullrange = TRUE) + #Use the fullrange so the lines are equal for all
    geom_point(alpha=0.5) + #Just for looking nice
    scale_color_manual(values = c("#44C8F5", "#F7941D", "#ED1B2F"), labels=c("CU", "MCI", "AD"), name='Diagnosis') +
    scale_fill_manual(values = c("#44C8F5", "#F7941D", "#ED1B2F"), labels=c("CU", "MCI", "AD"), name='Diagnosis') +
    theme_classic() +
    xlab("Temporal meta-ROI SUVR") +
    ylim(c(0,70)) + #Force limits to the expected spatial extent
    ylab("Spatial extent index (n/70)") +
    annotate("text", x=Inf, y=-Inf, hjust=1, vjust=-0.5, label=
    'CU \U03B2 = 36.89*** R\U00B2 adj = 0.46
     MCI \U03B2 = 48.52*** R\U00B2 adj = 0.80
     AD \U03B2 = 47.07*** R\U00B2 adj = 0.68\n') +
    theme(panel.grid.major = element_line(), #Reimports the axis grid (1/2)
          panel.grid.minor = element_line(), #Reimports the axis gris (1/2)
          #text = element_text(size=10, family="sans"), #Imposes font family and size
          text = element_text(family="sans"), #Imposes font family and size
          axis.title.x = element_text(face="bold"), #Bolds the axis title
          axis.title.y = element_text(face="bold"))
    
ggsave(glue("{figure_space}/suppfigure15_raw.png"), plot = plot_meta_spex, dpi=500)
```
